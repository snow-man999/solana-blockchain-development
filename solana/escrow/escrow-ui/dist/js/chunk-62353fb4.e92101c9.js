(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-62353fb4"],{"0276":function(e,t,n){"use strict";n("d9e2"),n("14d9"),n("13d5"),n("2c66"),n("249d"),n("40e9"),n("e9f5"),n("d866"),n("910d"),n("f665"),n("7d54"),n("ab43"),n("9485"),n("a732"),n("1e70"),n("79a4"),n("c1a1"),n("8b00"),n("a4e7"),n("1e5a"),n("72c3"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1");var r=n("1c35"),i=n("aecc"),s=n("399f"),o=n("0774"),a=n("d129"),c=n("fa13"),u=n("8df2"),l=n("748c"),d=n("8506"),h=n("502a"),b=n("ac87"),p=n("00e3"),g=n("fb4a");function m(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}function f(e){if(e&&"object"===typeof e&&"default"in e)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var y=m(s),k=m(o),w=f(u),S=m(h);const I=i.ed25519.utils.randomPrivateKey,A=()=>{const e=i.ed25519.utils.randomPrivateKey(),t=v(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),{publicKey:t,secretKey:n}},v=i.ed25519.getPublicKey;function _(e){try{return i.ed25519.ExtendedPoint.fromHex(e),!0}catch{return!1}}const P=(e,t)=>i.ed25519.sign(e,t.slice(0,32)),E=i.ed25519.verify,T=e=>r.Buffer.isBuffer(e)?e:e instanceof Uint8Array?r.Buffer.from(e.buffer,e.byteOffset,e.byteLength):r.Buffer.from(e);class O{constructor(e){Object.assign(this,e)}encode(){return r.Buffer.from(c.serialize(x,this))}static decode(e){return c.deserialize(x,this,e)}static decodeUnchecked(e){return c.deserializeUnchecked(x,this,e)}}class B extends O{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map(e=>{this.enum=e})}}const x=new Map;var C;const R=32,z=32;function L(e){return void 0!==e._bn}let N=1;class K extends O{constructor(e){if(super({}),this._bn=void 0,L(e))this._bn=e._bn;else{if("string"===typeof e){const t=k.default.decode(e);if(t.length!=z)throw new Error("Invalid public key input");this._bn=new y.default(t)}else this._bn=new y.default(e);if(this._bn.byteLength()>z)throw new Error("Invalid public key input")}}static unique(){const e=new K(N);return N+=1,new K(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return k.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(r.Buffer);if(e.length===z)return e;const t=r.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const i=r.Buffer.concat([e.toBuffer(),r.Buffer.from(t),n.toBuffer()]),s=a.sha256(i);return new K(s)}static createProgramAddressSync(e,t){let n=r.Buffer.alloc(0);e.forEach((function(e){if(e.length>R)throw new TypeError("Max seed length exceeded");n=r.Buffer.concat([n,T(e)])})),n=r.Buffer.concat([n,t.toBuffer(),r.Buffer.from("ProgramDerivedAddress")]);const i=a.sha256(n);if(_(i))throw new Error("Invalid seeds, address must fall off the curve");return new K(i)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n,i=255;while(0!=i){try{const s=e.concat(r.Buffer.from([i]));n=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;i--;continue}return[n,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new K(e);return _(t.toBytes())}}C=K,K.default=new C("11111111111111111111111111111111"),x.set(K,{kind:"struct",fields:[["_bn","u256"]]});class W{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=T(e);if(64!==e.length)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=T(I()),this._publicKey=T(v(this._secretKey))}get publicKey(){return new K(this._publicKey)}get secretKey(){return r.Buffer.concat([this._secretKey,this._publicKey],64)}}const j=new K("BPFLoader1111111111111111111111111111111111"),M=1232,U=127,q=64;class D extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(D.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class V extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature `+e+" using the Solana Explorer or CLI tools."),this.signature=void 0,this.signature=e}}Object.defineProperty(V.prototype,"name",{value:"TransactionExpiredTimeoutError"});class F extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(F.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class H{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){const t=255;if(this.length>t+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((e,t)=>{n.set(e.toBase58(),t)});const r=e=>{const t=n.get(e.toBase58());if(void 0===t)throw new Error("Encountered an unknown instruction account key during compilation");return t};return e.map(e=>({programIdIndex:r(e.programId),accountKeyIndexes:e.keys.map(e=>r(e.pubkey)),data:e.data}))}}const $=(e="publicKey")=>w.blob(32,e),G=(e="signature")=>w.blob(64,e),Y=(e="string")=>{const t=w.struct([w.u32("length"),w.u32("lengthPadding"),w.blob(w.offset(w.u32(),-8),"chars")],e),n=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(e,t)=>{const r=n(e,t);return r["chars"].toString()},s.encode=(e,t,n)=>{const s={chars:r.Buffer.from(e,"utf8")};return i(s,t,n)},s.alloc=e=>w.u32().span+w.u32().span+r.Buffer.from(e,"utf8").length,s},J=(e="authorized")=>w.struct([$("staker"),$("withdrawer")],e),X=(e="lockup")=>w.struct([w.ns64("unixTimestamp"),w.ns64("epoch"),$("custodian")],e),Z=(e="voteInit")=>w.struct([$("nodePubkey"),$("authorizedVoter"),$("authorizedWithdrawer"),w.u8("commission")],e),Q=(e="voteAuthorizeWithSeedArgs")=>w.struct([w.u32("voteAuthorizationType"),$("currentAuthorityDerivedKeyOwnerPubkey"),Y("currentAuthorityDerivedKeySeed"),$("newAuthorized")],e);function ee(e,t){const n=e=>{if(e.span>=0)return e.span;if("function"===typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const r=t[e.property];if(Array.isArray(r))return r.length*n(e.elementLayout)}else if("fields"in e)return ee({layout:e},t[e.property]);return 0};let r=0;return e.layout.fields.forEach(e=>{r+=n(e)}),r}function te(e){let t=0,n=0;for(;;){let r=e.shift();if(t|=(127&r)<<7*n,n+=1,0===(128&r))break}return t}function ne(e,t){let n=t;for(;;){let t=127&n;if(n>>=7,0==n){e.push(t);break}t|=128,e.push(t)}}function re(e,t){if(!e)throw new Error(t||"Assertion failed")}class ie{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,r=e=>{const t=e.toBase58();let r=n.get(t);return void 0===r&&(r={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(t,r)),r},i=r(t);i.isSigner=!0,i.isWritable=!0;for(const s of e){r(s.programId).isInvoked=!0;for(const e of s.keys){const t=r(e.pubkey);t.isSigner||(t.isSigner=e.isSigner),t.isWritable||(t.isWritable=e.isWritable)}}return new ie(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];re(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,e])=>e.isSigner&&e.isWritable),n=e.filter(([,e])=>e.isSigner&&!e.isWritable),r=e.filter(([,e])=>!e.isSigner&&e.isWritable),i=e.filter(([,e])=>!e.isSigner&&!e.isWritable),s={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:i.length};{re(t.length>0,"Expected at least one writable signer key");const[e]=t[0];re(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const o=[...t.map(([e])=>new K(e)),...n.map(([e])=>new K(e)),...r.map(([e])=>new K(e)),...i.map(([e])=>new K(e))];return[s,o]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&e.isWritable),[r,i]=this.drainKeysFoundInLookupTable(e.state.addresses,e=>!e.isSigner&&!e.isInvoked&&!e.isWritable);if(0!==t.length||0!==r.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:i}]}drainKeysFoundInLookupTable(e,t){const n=new Array,r=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new K(i),s=e.findIndex(e=>e.equals(t));s>=0&&(re(s<256,"Max lookup table index exceeded"),n.push(s),r.push(t),this.keyMetaMap.delete(i))}return[n,r]}}const se="Reached end of buffer unexpectedly";function oe(e){if(0===e.length)throw new Error(se);return e.shift()}function ae(e,...t){var n;const[r]=t;if(2===t.length?r+(null!==(n=t[1])&&void 0!==n?n:0)>e.length:r>=e.length)throw new Error(se);return e.splice(...t)}class ce{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(e=>new K(e)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:k.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new H(this.staticAccountKeys)}static compile(e){const t=ie.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new H(r),s=i.compileInstructions(e.instructions).map(e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:k.default.encode(e.data)}));return new ce({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,r=this.accountKeys.length-t,i=r-this.header.numReadonlyUnsignedAccounts;return n<i}{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];ne(t,e);const n=this.instructions.map(e=>{const{accounts:t,programIdIndex:n}=e,i=Array.from(k.default.decode(e.data));let s=[];ne(s,t.length);let o=[];return ne(o,i.length),{programIdIndex:n,keyIndicesCount:r.Buffer.from(s),keyIndices:t,dataLength:r.Buffer.from(o),data:i}});let i=[];ne(i,n.length);let s=r.Buffer.alloc(M);r.Buffer.from(i).copy(s);let o=i.length;n.forEach(e=>{const t=w.struct([w.u8("programIdIndex"),w.blob(e.keyIndicesCount.length,"keyIndicesCount"),w.seq(w.u8("keyIndex"),e.keyIndices.length,"keyIndices"),w.blob(e.dataLength.length,"dataLength"),w.seq(w.u8("userdatum"),e.data.length,"data")]),n=t.encode(e,s,o);o+=n}),s=s.slice(0,o);const a=w.struct([w.blob(1,"numRequiredSignatures"),w.blob(1,"numReadonlySignedAccounts"),w.blob(1,"numReadonlyUnsignedAccounts"),w.blob(t.length,"keyCount"),w.seq($("key"),e,"keys"),$("recentBlockhash")]),c={numRequiredSignatures:r.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:r.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:r.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:r.Buffer.from(t),keys:this.accountKeys.map(e=>T(e.toBytes())),recentBlockhash:k.default.decode(this.recentBlockhash)};let u=r.Buffer.alloc(2048);const l=a.encode(c,u);return s.copy(u,l),u.slice(0,l+s.length)}static from(e){let t=[...e];const n=oe(t);if(n!==(n&U))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=oe(t),s=oe(t),o=te(t);let a=[];for(let h=0;h<o;h++){const e=ae(t,0,z);a.push(new K(r.Buffer.from(e)))}const c=ae(t,0,z),u=te(t);let l=[];for(let h=0;h<u;h++){const e=oe(t),n=te(t),i=ae(t,0,n),s=te(t),o=ae(t,0,s),a=k.default.encode(r.Buffer.from(o));l.push({programIdIndex:e,accounts:i,data:a})}const d={header:{numRequiredSignatures:n,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:k.default.encode(r.Buffer.from(c)),accountKeys:a,instructions:l};return new ce(d)}}class ue{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new H(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const t=e-n,r=this.addressTableLookups.reduce((e,t)=>e+t.writableIndexes.length,0);return t<r}if(e>=this.header.numRequiredSignatures){const r=e-t,i=n-t,s=i-this.header.numReadonlyUnsignedAccounts;return r<s}{const n=t-this.header.numReadonlySignedAccounts;return e<n}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const r=e.find(e=>e.key.equals(n.accountKey));if(!r)throw new Error("Failed to find address lookup table account for table key "+n.accountKey.toBase58());for(const e of n.writableIndexes){if(!(e<r.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);t.writable.push(r.state.addresses[e])}for(const e of n.readonlyIndexes){if(!(e<r.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);t.readonly.push(r.state.addresses[e])}}return t}static compile(e){const t=ie.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const u of i){const e=t.extractTableLookup(u);if(void 0!==e){const[t,{writable:i,readonly:s}]=e;n.push(t),r.writable.push(...i),r.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new H(o,r),c=a.compileInstructions(e.instructions);return new ue({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:c,addressTableLookups:n})}serialize(){const e=Array();ne(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();ne(n,this.compiledInstructions.length);const r=this.serializeAddressTableLookups(),i=Array();ne(i,this.addressTableLookups.length);const s=w.struct([w.u8("prefix"),w.struct([w.u8("numRequiredSignatures"),w.u8("numReadonlySignedAccounts"),w.u8("numReadonlyUnsignedAccounts")],"header"),w.blob(e.length,"staticAccountKeysLength"),w.seq($(),this.staticAccountKeys.length,"staticAccountKeys"),$("recentBlockhash"),w.blob(n.length,"instructionsLength"),w.blob(t.length,"serializedInstructions"),w.blob(i.length,"addressTableLookupsLength"),w.blob(r.length,"serializedAddressTableLookups")]),o=new Uint8Array(M),a=128,c=s.encode({prefix:a,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(e=>e.toBytes()),recentBlockhash:k.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:r},o);return o.slice(0,c)}serializeInstructions(){let e=0;const t=new Uint8Array(M);for(const n of this.compiledInstructions){const r=Array();ne(r,n.accountKeyIndexes.length);const i=Array();ne(i,n.data.length);const s=w.struct([w.u8("programIdIndex"),w.blob(r.length,"encodedAccountKeyIndexesLength"),w.seq(w.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),w.blob(i.length,"encodedDataLength"),w.blob(n.data.length,"data")]);e+=s.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(M);for(const n of this.addressTableLookups){const r=Array();ne(r,n.writableIndexes.length);const i=Array();ne(i,n.readonlyIndexes.length);const s=w.struct([$("accountKey"),w.blob(r.length,"encodedWritableIndexesLength"),w.seq(w.u8(),n.writableIndexes.length,"writableIndexes"),w.blob(i.length,"encodedReadonlyIndexesLength"),w.seq(w.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=s.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=oe(t),r=n&U;re(n!==r,"Expected versioned message but received legacy message");const i=r;re(0===i,"Expected versioned message with version 0 but found version "+i);const s={numRequiredSignatures:oe(t),numReadonlySignedAccounts:oe(t),numReadonlyUnsignedAccounts:oe(t)},o=[],a=te(t);for(let b=0;b<a;b++)o.push(new K(ae(t,0,z)));const c=k.default.encode(ae(t,0,z)),u=te(t),l=[];for(let b=0;b<u;b++){const e=oe(t),n=te(t),r=ae(t,0,n),i=te(t),s=new Uint8Array(ae(t,0,i));l.push({programIdIndex:e,accountKeyIndexes:r,data:s})}const d=te(t),h=[];for(let b=0;b<d;b++){const e=new K(ae(t,0,z)),n=te(t),r=ae(t,0,n),i=te(t),s=ae(t,0,i);h.push({accountKey:e,writableIndexes:r,readonlyIndexes:s})}return new ue({header:s,staticAccountKeys:o,recentBlockhash:c,compiledInstructions:l,addressTableLookups:h})}}const le={deserializeMessageVersion(e){const t=e[0],n=t&U;return n===t?"legacy":n},deserialize:e=>{const t=le.deserializeMessageVersion(e);if("legacy"===t)return ce.from(e);if(0===t)return ue.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let de=function(e){return e[e["BLOCKHEIGHT_EXCEEDED"]=0]="BLOCKHEIGHT_EXCEEDED",e[e["PROCESSED"]=1]="PROCESSED",e[e["TIMED_OUT"]=2]="TIMED_OUT",e[e["NONCE_INVALID"]=3]="NONCE_INVALID",e}({});const he=r.Buffer.alloc(q).fill(0);class be{constructor(e){this.keys=void 0,this.programId=void 0,this.data=r.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class pe{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new be(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)n=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");n=this.signatures[0].publicKey}for(let p=0;p<t.length;p++)if(void 0===t[p].programId)throw new Error(`Transaction instruction index ${p} has undefined program id`);const r=[],i=[];t.forEach(e=>{e.keys.forEach(e=>{i.push({...e})});const t=e.programId.toString();r.includes(t)||r.push(t)}),r.forEach(e=>{i.push({pubkey:new K(e),isSigner:!1,isWritable:!1})});const s=[];i.forEach(e=>{const t=e.pubkey.toString(),n=s.findIndex(e=>e.pubkey.toString()===t);n>-1?(s[n].isWritable=s[n].isWritable||e.isWritable,s[n].isSigner=s[n].isSigner||e.isSigner):s.push(e)}),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;const n={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",n)}));const o=s.findIndex(e=>e.pubkey.equals(n));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const p of this.signatures){const e=s.findIndex(e=>e.pubkey.equals(p.publicKey));if(!(e>-1))throw new Error("unknown signer: "+p.publicKey.toString());s[e].isSigner||(s[e].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,c=0,u=0;const l=[],d=[];s.forEach(({pubkey:e,isSigner:t,isWritable:n})=>{t?(l.push(e.toString()),a+=1,n||(c+=1)):(d.push(e.toString()),n||(u+=1))});const h=l.concat(d),b=t.map(e=>{const{data:t,programId:n}=e;return{programIdIndex:h.indexOf(n.toString()),accounts:e.keys.map(e=>h.indexOf(e.pubkey.toString())),data:k.default.encode(t)}});return b.forEach(e=>{re(e.programIdIndex>=0),e.accounts.forEach(e=>re(e>=0))}),new ce({header:{numRequiredSignatures:a,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},accountKeys:h,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){const n=this.signatures.every((e,n)=>t[n].equals(e.publicKey));if(n)return e}return this.signatures=t.map(e=>({signature:null,publicKey:e})),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter(e=>{const n=e.toString();return!t.has(n)&&(t.add(n),!0)}).map(e=>({signature:null,publicKey:e}))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,n=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),n.push(i))}this.signatures=n.map(e=>({signature:null,publicKey:e.publicKey}));const r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,n=[];for(const i of e){const e=i.publicKey.toString();t.has(e)||(t.add(e),n.push(i))}const r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(e=>{const t=P(n,e.secretKey);this._addSignature(e.publicKey,T(t))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){re(64===t.length);const n=this.signatures.findIndex(t=>e.equals(t.publicKey));if(n<0)throw new Error("unknown signer: "+e.toString());this.signatures[n].signature=r.Buffer.from(t)}verifySignatures(e=!0){const t=this._getMessageSignednessErrors(this.serializeMessage(),e);return!t}_getMessageSignednessErrors(e,t){const n={};for(const{signature:r,publicKey:i}of this.signatures)null===r?t&&(n.missing||(n.missing=[])).push(i):E(r,e,i.toBytes())||(n.invalid||(n.invalid=[])).push(i);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){const e=this._getMessageSignednessErrors(r,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map(e=>e.toBase58()).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map(e=>e.toBase58()).join("`, `")}\`].`),new Error(t)}}return this._serialize(r)}_serialize(e){const{signatures:t}=this,n=[];ne(n,t.length);const i=n.length+64*t.length+e.length,s=r.Buffer.alloc(i);return re(t.length<256),r.Buffer.from(n).copy(s,0),t.forEach(({signature:e},t)=>{null!==e&&(re(64===e.length,"signature has invalid length"),r.Buffer.from(e).copy(s,n.length+64*t))}),e.copy(s,n.length+64*t.length),re(s.length<=M,`Transaction too large: ${s.length} > ${M}`),s}get keys(){return re(1===this.instructions.length),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return re(1===this.instructions.length),this.instructions[0].programId}get data(){return re(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const n=te(t);let i=[];for(let s=0;s<n;s++){const e=ae(t,0,q);i.push(k.default.encode(r.Buffer.from(e)))}return pe.populate(ce.from(t),i)}static populate(e,t=[]){const n=new pe;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((t,r)=>{const i={signature:t==k.default.encode(he)?null:k.default.decode(t),publicKey:e.accountKeys[r]};n.signatures.push(i)}),e.instructions.forEach(t=>{const r=t.accounts.map(t=>{const r=e.accountKeys[t];return{pubkey:r,isSigner:n.signatures.some(e=>e.publicKey.toString()===r.toString())||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}});n.instructions.push(new be({keys:r,programId:e.accountKeys[t.programIdIndex],data:k.default.decode(t.data)}))}),n._message=e,n._json=n.toJSON(),n}}class ge{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:r,recentBlockhash:i}=e,{numRequiredSignatures:s,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=n,c=s-o;re(c>0,"Message header is invalid");const u=e.staticAccountKeys.length-s-a;re(u>=0,"Message header is invalid");const l=e.getAccountKeys(t),d=l.get(0);if(void 0===d)throw new Error("Failed to decompile message because no account keys were found");const h=[];for(const b of r){const e=[];for(const r of b.accountKeyIndexes){const t=l.get(r);if(void 0===t)throw new Error("Failed to find key for account key index "+r);const i=r<s;let o;o=i?r<c:r<l.staticAccountKeys.length?r-s<u:r-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,e.push({pubkey:t,isSigner:r<n.numRequiredSignatures,isWritable:o})}const t=l.get(b.programIdIndex);if(void 0===t)throw new Error("Failed to find program id for program id index "+b.programIdIndex);h.push(new be({programId:t,data:T(b.data),keys:e}))}return new ge({payerKey:d,instructions:h,recentBlockhash:i})}compileToLegacyMessage(){return ce.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return ue.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class me{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)re(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let n=0;n<e.header.numRequiredSignatures;n++)t.push(new Uint8Array(q));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();ne(t,this.signatures.length);const n=w.struct([w.blob(t.length,"encodedSignaturesLength"),w.seq(G(),this.signatures.length,"signatures"),w.blob(e.length,"serializedMessage")]),r=new Uint8Array(2048),i=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,i)}static deserialize(e){let t=[...e];const n=[],r=te(t);for(let s=0;s<r;s++)n.push(new Uint8Array(ae(t,0,q)));const i=le.deserialize(new Uint8Array(t));return new me(i,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const r of e){const e=n.findIndex(e=>e.equals(r.publicKey));re(e>=0,"Cannot sign with non signer key "+r.publicKey.toBase58()),this.signatures[e]=P(t,r.secretKey)}}addSignature(e,t){re(64===t.byteLength,"Signature must be 64 bytes long");const n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures),r=n.findIndex(t=>t.equals(e));re(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const fe=160,ye=64,ke=fe/ye,we=1e3/ke,Se=new K("SysvarC1ock11111111111111111111111111111111"),Ie=new K("SysvarEpochSchedu1e111111111111111111111111"),Ae=new K("Sysvar1nstructions1111111111111111111111111"),ve=new K("SysvarRecentB1ockHashes11111111111111111111"),_e=new K("SysvarRent111111111111111111111111111111111"),Pe=new K("SysvarRewards111111111111111111111111111111"),Ee=new K("SysvarS1otHashes111111111111111111111111111"),Te=new K("SysvarS1otHistory11111111111111111111111111"),Oe=new K("SysvarStakeHistory1111111111111111111111111");class Be extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){const i=r?`Logs: \n${JSON.stringify(r.slice(-10),null,2)}. `:"",s="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let o;switch(e){case"send":o=`Transaction ${t} resulted in an error. \n`+n+". "+i+s;break;case"simulate":o=`Simulation failed. \nMessage: ${n}. \n`+i+s;break;default:o=`Unknown action '${(e=>e)(e)}'`}super(o),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(null==e||"object"!==typeof e||!("then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(e=>{if(e&&e.meta&&e.meta.logMessages){const n=e.meta.logMessages;this.transactionLogs=n,t(n)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}const xe={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class Ce extends Error{constructor({code:e,message:t,data:n},r){super(null!=r?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}async function Re(e,t,n,r){const i=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},s=await e.sendTransaction(t,n,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:null===r||void 0===r?void 0:r.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},r&&r.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:n}=t.nonceInfo,i=n.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:null===r||void 0===r?void 0:r.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},r&&r.commitment)).value}else null!=(null===r||void 0===r?void 0:r.abortSignal)&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await e.confirmTransaction(s,r&&r.commitment)).value;if(o.err){if(null!=s)throw new Be({action:"send",signature:s,transactionMessage:`Status: (${JSON.stringify(o)})`});throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`)}return s}function ze(e){return new Promise(t=>setTimeout(t,e))}function Le(e,t){const n=e.layout.span>=0?e.layout.span:ee(e,t),i=r.Buffer.alloc(n),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,i),i}function Ne(e,t){let n;try{n=e.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(n.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);return n}const Ke=w.nu64("lamportsPerSignature"),We=w.struct([w.u32("version"),w.u32("state"),$("authorizedPubkey"),$("nonce"),w.struct([Ke],"feeCalculator")]),je=We.span;class Me{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=We.decode(T(e),0);return new Me({authorizedPubkey:new K(t.authorizedPubkey),nonce:new K(t.nonce).toString(),feeCalculator:t.feeCalculator})}}function Ue(e){const t=u.blob(8,e),n=t.decode.bind(t),r=t.encode.bind(t),i=t,s=l.getU64Codec();return i.decode=(e,t)=>{const r=n(e,t);return s.decode(r)},i.encode=(e,t,n)=>{const i=s.encode(e);return r(i,t,n)},i}class qe{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=w.u32("instruction"),n=t.decode(e.data);let r;for(const[i,s]of Object.entries(De))if(s.index==n){r=i;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:r}=Ne(De.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new K(r)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=Ne(De.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:r}=Ne(De.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new K(r)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=Ne(De.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:r,programId:i}=Ne(De.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new K(t),seed:n,space:r,programId:new K(i)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=Ne(De.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new K(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:r}=Ne(De.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new K(t),seed:n,programId:new K(r)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:r,space:i,programId:s}=Ne(De.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new K(t),seed:n,lamports:r,space:i,programId:new K(s)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=Ne(De.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new K(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Ne(De.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Ne(De.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=Ne(De.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new K(t)}}static checkProgramId(e){if(!e.equals(Ve.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const De=Object.freeze({Create:{index:0,layout:w.struct([w.u32("instruction"),w.ns64("lamports"),w.ns64("space"),$("programId")])},Assign:{index:1,layout:w.struct([w.u32("instruction"),$("programId")])},Transfer:{index:2,layout:w.struct([w.u32("instruction"),Ue("lamports")])},CreateWithSeed:{index:3,layout:w.struct([w.u32("instruction"),$("base"),Y("seed"),w.ns64("lamports"),w.ns64("space"),$("programId")])},AdvanceNonceAccount:{index:4,layout:w.struct([w.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:w.struct([w.u32("instruction"),w.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:w.struct([w.u32("instruction"),$("authorized")])},AuthorizeNonceAccount:{index:7,layout:w.struct([w.u32("instruction"),$("authorized")])},Allocate:{index:8,layout:w.struct([w.u32("instruction"),w.ns64("space")])},AllocateWithSeed:{index:9,layout:w.struct([w.u32("instruction"),$("base"),Y("seed"),w.ns64("space"),$("programId")])},AssignWithSeed:{index:10,layout:w.struct([w.u32("instruction"),$("base"),Y("seed"),$("programId")])},TransferWithSeed:{index:11,layout:w.struct([w.u32("instruction"),Ue("lamports"),Y("seed"),$("programId")])},UpgradeNonceAccount:{index:12,layout:w.struct([w.u32("instruction")])}});class Ve{constructor(){}static createAccount(e){const t=De.Create,n=Le(t,{lamports:e.lamports,space:e.space,programId:T(e.programId.toBuffer())});return new be({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const r=De.TransferWithSeed;t=Le(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:T(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=De.Transfer;t=Le(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new be({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const r=De.AssignWithSeed;t=Le(r,{base:T(e.basePubkey.toBuffer()),seed:e.seed,programId:T(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=De.Assign;t=Le(r,{programId:T(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new be({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=De.CreateWithSeed,n=Le(t,{base:T(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:T(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new be({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){const t=new pe;"basePubkey"in e&&"seed"in e?t.add(Ve.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:je,programId:this.programId})):t.add(Ve.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:je,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=De.InitializeNonceAccount,n=Le(t,{authorized:T(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new be(r)}static nonceAdvance(e){const t=De.AdvanceNonceAccount,n=Le(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new be(r)}static nonceWithdraw(e){const t=De.WithdrawNonceAccount,n=Le(t,{lamports:e.lamports});return new be({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=De.AuthorizeNonceAccount,n=Le(t,{authorized:T(e.newAuthorizedPubkey.toBuffer())});return new be({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const r=De.AllocateWithSeed;t=Le(r,{base:T(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:T(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=De.Allocate;t=Le(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new be({keys:n,programId:this.programId,data:t})}}Ve.programId=new K("11111111111111111111111111111111");const Fe=M-300;class He{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/He.chunkSize)+1+1)}static async load(e,t,n,i,s){{const r=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(n.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==s.length&&(a=a||new pe,a.add(Ve.allocate({accountPubkey:n.publicKey,space:s.length}))),o.owner.equals(i)||(a=a||new pe,a.add(Ve.assign({accountPubkey:n.publicKey,programId:i}))),o.lamports<r&&(a=a||new pe,a.add(Ve.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:r-o.lamports})))}else a=(new pe).add(Ve.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:r>0?r:1,space:s.length,programId:i}));null!==a&&await Re(e,a,[t,n],{commitment:"confirmed"})}const o=w.struct([w.u32("instruction"),w.u32("offset"),w.u32("bytesLength"),w.u32("bytesLengthPadding"),w.seq(w.u8("byte"),w.offset(w.u32(),-8),"bytes")]),a=He.chunkSize;let c=0,u=s,l=[];while(u.length>0){const s=u.slice(0,a),d=r.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new pe).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:d});if(l.push(Re(e,h,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await ze(1e3/e)}c+=a,u=u.slice(a)}await Promise.all(l);{const s=w.struct([w.u32("instruction")]),o=r.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new pe).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:i,data:o}),c="processed",u=await e.sendTransaction(a,[t,n],{preflightCommitment:c}),{context:l,value:d}=await e.confirmTransaction({signature:u,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},c);if(d.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(d)})`);while(1){try{const t=await e.getSlot({commitment:c});if(t>l.slot)break}catch{}await new Promise(e=>setTimeout(e,Math.round(we/2)))}}return!0}}He.chunkSize=Fe;const $e=new K("BPFLoader2111111111111111111111111111111111");class Ge{static getMinNumSignatures(e){return He.getMinNumSignatures(e)}static load(e,t,n,r,i){return He.load(e,t,n,i,r)}}function Ye(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e["default"]:e}var Je,Xe;function Ze(){if(Xe)return Je;Xe=1;var e=Object.prototype.toString,t=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};function n(r,i){var s,o,a,c,u,l,d;if(!0===r)return"true";if(!1===r)return"false";switch(typeof r){case"object":if(null===r)return null;if(r.toJSON&&"function"===typeof r.toJSON)return n(r.toJSON(),i);if(d=e.call(r),"[object Array]"===d){for(a="[",o=r.length-1,s=0;s<o;s++)a+=n(r[s],!0)+",";return o>-1&&(a+=n(r[s],!0)),a+"]"}if("[object Object]"===d){c=t(r).sort(),o=c.length,a="",s=0;while(s<o)u=c[s],l=n(r[u],!1),void 0!==l&&(a&&(a+=","),a+=JSON.stringify(u)+":"+l),s++;return"{"+a+"}"}return JSON.stringify(r);case"function":case"undefined":return i?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}return Je=function(e){var t=n(e,!1);if(void 0!==t)return""+t},Je}var Qe=Ze(),et=Ye(Qe);const tt=32;function nt(e){let t=0;while(e>1)e/=2,t++;return t}function rt(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,e|=e>>32,e+1)}class it{constructor(e,t,n,r,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=i}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=nt(rt(e+tt+1))-nt(tt)-1,n=this.getSlotsInEpoch(t),r=e-(n-tt);return[t,r]}{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,i=t%this.slotsPerEpoch;return[r,i]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*tt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+nt(tt)):this.slotsPerEpoch}}var st=globalThis.fetch;class ot extends b.CommonClient{constructor(e,t,n){const r=e=>{const n=b.WebSocket(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return this.underlyingSocket="socket"in n?n.socket:n,n};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){var t;const n=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===n?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}notify(...e){var t;const n=null===(t=this.underlyingSocket)||void 0===t?void 0:t.readyState;return 1===n?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}}function at(e,t){let n;try{n=e.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(n.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);return n}const ct=56;class ut{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=at(lt,e),n=e.length-ct;re(n>=0,"lookup table is invalid"),re(n%32===0,"lookup table is invalid");const r=n/32,{addresses:i}=w.struct([w.seq($(),r,"addresses")]).decode(e.slice(ct));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new K(t.authority[0]):void 0,addresses:i.map(e=>new K(e))}}}const lt={index:1,layout:w.struct([w.u32("typeIndex"),Ue("deactivationSlot"),w.nu64("lastExtendedSlot"),w.u8("lastExtendedStartIndex"),w.u8(),w.seq($(),w.offset(w.u8(),-1),"authority")])},dt=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function ht(e){const t=e.match(dt);if(null==t)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[n,r,i,s]=t,o=e.startsWith("https:")?"wss:":"ws:",a=null==i?null:parseInt(i.slice(1),10),c=null==a?"":":"+(a+1);return`${o}//${r}${c}${s}`}const bt=d.coerce(d.instance(K),d.string(),e=>new K(e)),pt=d.tuple([d.string(),d.literal("base64")]),gt=d.coerce(d.instance(r.Buffer),pt,e=>r.Buffer.from(e[0],"base64")),mt=3e4;function ft(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}function yt(e){let t,n;if("string"===typeof e)t=e;else if(e){const{commitment:r,...i}=e;t=r,n=i}return{commitment:t,config:n}}function kt(e){return e.map(e=>{var t;return"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:null!==(t=e.memcmp.encoding)&&void 0!==t?t:"base58"}}:e})}function wt(e){return d.union([d.type({jsonrpc:d.literal("2.0"),id:d.string(),result:e}),d.type({jsonrpc:d.literal("2.0"),id:d.string(),error:d.type({code:d.unknown(),message:d.string(),data:d.optional(d.any())})})])}const St=wt(d.unknown());function It(e){return d.coerce(wt(e),St,t=>"error"in t?t:{...t,result:d.create(t.result,e)})}function At(e){return It(d.type({context:d.type({slot:d.number()}),value:e}))}function vt(e){return d.type({context:d.type({slot:d.number()}),value:e})}function _t(e,t){return 0===e?new ue({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new K(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:k.default.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new ce(t)}const Pt=d.type({foundation:d.number(),foundationTerm:d.number(),initial:d.number(),taper:d.number(),terminal:d.number()}),Et=It(d.array(d.nullable(d.type({epoch:d.number(),effectiveSlot:d.number(),amount:d.number(),postBalance:d.number(),commission:d.optional(d.nullable(d.number()))})))),Tt=d.array(d.type({slot:d.number(),prioritizationFee:d.number()})),Ot=d.type({total:d.number(),validator:d.number(),foundation:d.number(),epoch:d.number()}),Bt=d.type({epoch:d.number(),slotIndex:d.number(),slotsInEpoch:d.number(),absoluteSlot:d.number(),blockHeight:d.optional(d.number()),transactionCount:d.optional(d.number())}),xt=d.type({slotsPerEpoch:d.number(),leaderScheduleSlotOffset:d.number(),warmup:d.boolean(),firstNormalEpoch:d.number(),firstNormalSlot:d.number()}),Ct=d.record(d.string(),d.array(d.number())),Rt=d.nullable(d.union([d.type({}),d.string()])),zt=d.type({err:Rt}),Lt=d.literal("receivedSignature"),Nt=d.type({"solana-core":d.string(),"feature-set":d.optional(d.number())}),Kt=d.type({program:d.string(),programId:bt,parsed:d.unknown()}),Wt=d.type({programId:bt,accounts:d.array(bt),data:d.string()}),jt=At(d.type({err:d.nullable(d.union([d.type({}),d.string()])),logs:d.nullable(d.array(d.string())),accounts:d.optional(d.nullable(d.array(d.nullable(d.type({executable:d.boolean(),owner:d.string(),lamports:d.number(),data:d.array(d.string()),rentEpoch:d.optional(d.number())}))))),unitsConsumed:d.optional(d.number()),returnData:d.optional(d.nullable(d.type({programId:d.string(),data:d.tuple([d.string(),d.literal("base64")])}))),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(d.union([Kt,Wt]))}))))})),Mt=At(d.type({byIdentity:d.record(d.string(),d.array(d.number())),range:d.type({firstSlot:d.number(),lastSlot:d.number()})}));function Ut(e,t,n,r,i,s){const o=n||st;let a,c;null!=s&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),r&&(c=async(e,t)=>{const n=await new Promise((n,i)=>{try{r(e,t,(e,t)=>n([e,t]))}catch(s){i(s)}});return await o(...n)});const u=new S.default(async(n,r)=>{const s={method:"POST",body:n,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},lr)};try{let t,n=5,a=500;for(;;){if(t=c?await c(e,s):await o(e,s),429!==t.status)break;if(!0===i)break;if(n-=1,0===n)break;console.error(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${a}ms delay...`),await ze(a),a*=2}const u=await t.text();t.ok?r(null,u):r(new Error(`${t.status} ${t.statusText}: ${u}`))}catch(u){u instanceof Error&&r(u)}},{});return u}function qt(e){return(t,n)=>new Promise((r,i)=>{e.request(t,n,(e,t)=>{e?i(e):r(t)})})}function Dt(e){return t=>new Promise((n,r)=>{0===t.length&&n([]);const i=t.map(t=>e.request(t.methodName,t.args));e.request(i,(e,t)=>{e?r(e):n(t)})})}const Vt=It(Pt),Ft=It(Ot),Ht=It(Tt),$t=It(Bt),Gt=It(xt),Yt=It(Ct),Jt=It(d.number()),Xt=At(d.type({total:d.number(),circulating:d.number(),nonCirculating:d.number(),nonCirculatingAccounts:d.array(bt)})),Zt=d.type({amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}),Qt=At(d.array(d.type({address:bt,amount:d.string(),uiAmount:d.nullable(d.number()),decimals:d.number(),uiAmountString:d.optional(d.string())}))),en=At(d.array(d.type({pubkey:bt,account:d.type({executable:d.boolean(),owner:bt,lamports:d.number(),data:gt,rentEpoch:d.number()})}))),tn=d.type({program:d.string(),parsed:d.unknown(),space:d.number()}),nn=At(d.array(d.type({pubkey:bt,account:d.type({executable:d.boolean(),owner:bt,lamports:d.number(),data:tn,rentEpoch:d.number()})}))),rn=At(d.array(d.type({lamports:d.number(),address:bt}))),sn=d.type({executable:d.boolean(),owner:bt,lamports:d.number(),data:gt,rentEpoch:d.number()}),on=d.type({pubkey:bt,account:sn}),an=d.coerce(d.union([d.instance(r.Buffer),tn]),d.union([pt,tn]),e=>Array.isArray(e)?d.create(e,gt):e),cn=d.type({executable:d.boolean(),owner:bt,lamports:d.number(),data:an,rentEpoch:d.number()}),un=d.type({pubkey:bt,account:cn}),ln=d.type({state:d.union([d.literal("active"),d.literal("inactive"),d.literal("activating"),d.literal("deactivating")]),active:d.number(),inactive:d.number()}),dn=It(d.array(d.type({signature:d.string(),slot:d.number(),err:Rt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),hn=It(d.array(d.type({signature:d.string(),slot:d.number(),err:Rt,memo:d.nullable(d.string()),blockTime:d.optional(d.nullable(d.number()))}))),bn=d.type({subscription:d.number(),result:vt(sn)}),pn=d.type({pubkey:bt,account:sn}),gn=d.type({subscription:d.number(),result:vt(pn)}),mn=d.type({parent:d.number(),slot:d.number(),root:d.number()}),fn=d.type({subscription:d.number(),result:mn}),yn=d.union([d.type({type:d.union([d.literal("firstShredReceived"),d.literal("completed"),d.literal("optimisticConfirmation"),d.literal("root")]),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("createdBank"),parent:d.number(),slot:d.number(),timestamp:d.number()}),d.type({type:d.literal("frozen"),slot:d.number(),timestamp:d.number(),stats:d.type({numTransactionEntries:d.number(),numSuccessfulTransactions:d.number(),numFailedTransactions:d.number(),maxTransactionsPerEntry:d.number()})}),d.type({type:d.literal("dead"),slot:d.number(),timestamp:d.number(),err:d.string()})]),kn=d.type({subscription:d.number(),result:yn}),wn=d.type({subscription:d.number(),result:vt(d.union([zt,Lt]))}),Sn=d.type({subscription:d.number(),result:d.number()}),In=d.type({pubkey:d.string(),gossip:d.nullable(d.string()),tpu:d.nullable(d.string()),rpc:d.nullable(d.string()),version:d.nullable(d.string())}),An=d.type({votePubkey:d.string(),nodePubkey:d.string(),activatedStake:d.number(),epochVoteAccount:d.boolean(),epochCredits:d.array(d.tuple([d.number(),d.number(),d.number()])),commission:d.number(),lastVote:d.number(),rootSlot:d.nullable(d.number())}),vn=It(d.type({current:d.array(An),delinquent:d.array(An)})),_n=d.union([d.literal("processed"),d.literal("confirmed"),d.literal("finalized")]),Pn=d.type({slot:d.number(),confirmations:d.nullable(d.number()),err:Rt,confirmationStatus:d.optional(_n)}),En=At(d.array(d.nullable(Pn))),Tn=It(d.number()),On=d.type({accountKey:bt,writableIndexes:d.array(d.number()),readonlyIndexes:d.array(d.number())}),Bn=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(d.string()),header:d.type({numRequiredSignatures:d.number(),numReadonlySignedAccounts:d.number(),numReadonlyUnsignedAccounts:d.number()}),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()})),recentBlockhash:d.string(),addressTableLookups:d.optional(d.array(On))})}),xn=d.type({pubkey:bt,signer:d.boolean(),writable:d.boolean(),source:d.optional(d.union([d.literal("transaction"),d.literal("lookupTable")]))}),Cn=d.type({accountKeys:d.array(xn),signatures:d.array(d.string())}),Rn=d.type({parsed:d.unknown(),program:d.string(),programId:bt}),zn=d.type({accounts:d.array(bt),data:d.string(),programId:bt}),Ln=d.union([zn,Rn]),Nn=d.union([d.type({parsed:d.unknown(),program:d.string(),programId:d.string()}),d.type({accounts:d.array(d.string()),data:d.string(),programId:d.string()})]),Kn=d.coerce(Ln,Nn,e=>"accounts"in e?d.create(e,zn):d.create(e,Rn)),Wn=d.type({signatures:d.array(d.string()),message:d.type({accountKeys:d.array(xn),instructions:d.array(Kn),recentBlockhash:d.string(),addressTableLookups:d.optional(d.nullable(d.array(On)))})}),jn=d.type({accountIndex:d.number(),mint:d.string(),owner:d.optional(d.string()),programId:d.optional(d.string()),uiTokenAmount:Zt}),Mn=d.type({writable:d.array(bt),readonly:d.array(bt)}),Un=d.type({err:Rt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(d.type({accounts:d.array(d.number()),data:d.string(),programIdIndex:d.number()}))})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(jn))),postTokenBalances:d.optional(d.nullable(d.array(jn))),loadedAddresses:d.optional(Mn),computeUnitsConsumed:d.optional(d.number()),costUnits:d.optional(d.number())}),qn=d.type({err:Rt,fee:d.number(),innerInstructions:d.optional(d.nullable(d.array(d.type({index:d.number(),instructions:d.array(Kn)})))),preBalances:d.array(d.number()),postBalances:d.array(d.number()),logMessages:d.optional(d.nullable(d.array(d.string()))),preTokenBalances:d.optional(d.nullable(d.array(jn))),postTokenBalances:d.optional(d.nullable(d.array(jn))),loadedAddresses:d.optional(Mn),computeUnitsConsumed:d.optional(d.number()),costUnits:d.optional(d.number())}),Dn=d.union([d.literal(0),d.literal("legacy")]),Vn=d.type({pubkey:d.string(),lamports:d.number(),postBalance:d.nullable(d.number()),rewardType:d.nullable(d.string()),commission:d.optional(d.nullable(d.number()))}),Fn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Bn,meta:d.nullable(Un),version:d.optional(Dn)})),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Hn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),$n=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Cn,meta:d.nullable(Un),version:d.optional(Dn)})),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Gn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Wn,meta:d.nullable(qn),version:d.optional(Dn)})),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Yn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Cn,meta:d.nullable(qn),version:d.optional(Dn)})),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Jn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number()),blockHeight:d.nullable(d.number())}))),Xn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),transactions:d.array(d.type({transaction:Bn,meta:d.nullable(Un)})),rewards:d.optional(d.array(Vn)),blockTime:d.nullable(d.number())}))),Zn=It(d.nullable(d.type({blockhash:d.string(),previousBlockhash:d.string(),parentSlot:d.number(),signatures:d.array(d.string()),blockTime:d.nullable(d.number())}))),Qn=It(d.nullable(d.type({slot:d.number(),meta:d.nullable(Un),blockTime:d.optional(d.nullable(d.number())),transaction:Bn,version:d.optional(Dn)}))),er=It(d.nullable(d.type({slot:d.number(),transaction:Wn,meta:d.nullable(qn),blockTime:d.optional(d.nullable(d.number())),version:d.optional(Dn)}))),tr=At(d.type({blockhash:d.string(),lastValidBlockHeight:d.number()})),nr=At(d.boolean()),rr=d.type({slot:d.number(),numTransactions:d.number(),numSlots:d.number(),samplePeriodSecs:d.number()}),ir=It(d.array(rr)),sr=At(d.nullable(d.type({feeCalculator:d.type({lamportsPerSignature:d.number()})}))),or=It(d.string()),ar=It(d.string()),cr=d.type({err:Rt,logs:d.array(d.string()),signature:d.string()}),ur=d.type({result:vt(cr),subscription:d.number()}),lr={"solana-client":"js/1.0.0-maintenance"};class dr{constructor(e,t){let n,r,i,s,o,a;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async t=>{var n;const{commitment:r,config:i}=yt(t),s=this._buildArgs([],r,void 0,i),o=et(s);return e[o]=null!==(n=e[o])&&void 0!==n?n:(async()=>{try{const t=await this._rpcRequest("getBlockHeight",s),n=d.create(t,It(d.number()));if("error"in n)throw new Ce(n.error,"failed to get block height information");return n.result}finally{delete e[o]}})(),await e[o]}})(),t&&"string"===typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,i=t.fetch,s=t.fetchMiddleware,o=t.disableRetryOnRateLimit,a=t.httpAgent),this._rpcEndpoint=ft(e),this._rpcWsEndpoint=n||ht(e),this._rpcClient=Ut(e,r,i,s,o,a),this._rpcRequest=qt(this._rpcClient),this._rpcBatchRequest=Dt(this._rpcClient),this._rpcWebSocket=new ot(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgs([e.toBase58()],n,void 0,r),s=await this._rpcRequest("getBalance",i),o=d.create(s,At(d.number()));if("error"in o)throw new Ce(o.error,"failed to get balance for "+e.toBase58());return o.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=d.create(t,It(d.nullable(d.number())));if("error"in n)throw new Ce(n.error,"failed to get block time for slot "+e);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=d.create(e,It(d.number()));if("error"in t)throw new Ce(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=d.create(e,Jt);if("error"in t)throw new Ce(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};t="string"===typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),r=d.create(n,Xt);if("error"in r)throw new Ce(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),i=d.create(r,At(Zt));if("error"in i)throw new Ce(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),i=d.create(r,At(Zt));if("error"in i)throw new Ce(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(e,t,n){const{commitment:r,config:i}=yt(n);let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,r,"base64",i),a=await this._rpcRequest("getTokenAccountsByOwner",o),c=d.create(a,en);if("error"in c)throw new Ce(c.error,"failed to get token accounts owned by account "+e.toBase58());return c.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});const i=this._buildArgs(r,n,"jsonParsed"),s=await this._rpcRequest("getTokenAccountsByOwner",i),o=d.create(s,nn);if("error"in o)throw new Ce(o.error,"failed to get token accounts owned by account "+e.toBase58());return o.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),i=d.create(r,rn);if("error"in i)throw new Ce(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),i=d.create(r,Qt);if("error"in i)throw new Ce(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgs([e.toBase58()],n,"base64",r),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,At(d.nullable(sn)));if("error"in o)throw new Ce(o.error,"failed to get info about account "+e.toBase58());return o.result}async getParsedAccountInfo(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgs([e.toBase58()],n,"jsonParsed",r),s=await this._rpcRequest("getAccountInfo",i),o=d.create(s,At(d.nullable(cn)));if("error"in o)throw new Ce(o.error,"failed to get info about account "+e.toBase58());return o.result}async getAccountInfo(e,t){try{const n=await this.getAccountInfoAndContext(e,t);return n.value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:r}=yt(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],n,"jsonParsed",r),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,At(d.array(d.nullable(cn))));if("error"in a)throw new Ce(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:r}=yt(t),i=e.map(e=>e.toBase58()),s=this._buildArgs([i],n,"base64",r),o=await this._rpcRequest("getMultipleAccounts",s),a=d.create(o,At(d.array(d.nullable(sn))));if("error"in a)throw new Ce(a.error,"failed to get info for accounts "+i);return a.result}async getMultipleAccountsInfo(e,t){const n=await this.getMultipleAccountsInfoAndContext(e,t);return n.value}async getStakeActivation(e,t,n){const{commitment:r,config:i}=yt(t),s=this._buildArgs([e.toBase58()],r,void 0,{...i,epoch:null!=n?n:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getStakeActivation",s),a=d.create(o,It(ln));if("error"in a)throw new Ce(a.error,"failed to get Stake Activation "+e.toBase58());return a.result}async getProgramAccounts(e,t){const{commitment:n,config:r}=yt(t),{encoding:i,...s}=r||{},o=this._buildArgs([e.toBase58()],n,i||"base64",{...s,...s.filters?{filters:kt(s.filters)}:null}),a=await this._rpcRequest("getProgramAccounts",o),c=d.array(on),u=!0===s.withContext?d.create(a,At(c)):d.create(a,It(c));if("error"in u)throw new Ce(u.error,"failed to get accounts owned by program "+e.toBase58());return u.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgs([e.toBase58()],n,"jsonParsed",r),s=await this._rpcRequest("getProgramAccounts",i),o=d.create(s,It(d.array(un)));if("error"in o)throw new Ce(o.error,"failed to get accounts owned by program "+e.toBase58());return o.result}async confirmTransaction(e,t){let n,r;if("string"==typeof e)n=e;else{var i;const t=e;if(null!==(i=t.abortSignal)&&void 0!==i&&i.aborted)return Promise.reject(t.abortSignal.reason);n=t.signature}try{r=k.default.decode(n)}catch(s){throw new Error("signature must be base58 encoded: "+n)}return re(64===r.length,"signature has invalid length"),"string"===typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{null!=e&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,i=!1;const s=new Promise((s,o)=>{try{n=this.onSignature(t,(e,t)=>{n=void 0;const r={context:t,value:e};s({__type:de.PROCESSED,response:r})},e);const a=new Promise(e=>{null==n?e():r=this._onSubscriptionStateChange(n,t=>{"subscribed"===t&&e()})});(async()=>{if(await a,i)return;const n=await this.getSignatureStatus(t);if(i)return;if(null==n)return;const{context:r,value:c}=n;if(null!=c)if(null!==c&&void 0!==c&&c.err)o(c.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return;break;case"processed":case"recent":}i=!0,s({__type:de.PROCESSED,response:{context:r,value:c}})}})()}catch(a){o(a)}}),o=()=>{r&&(r(),r=void 0),null!=n&&(this.removeSignatureListener(n),n=void 0)};return{abortConfirmation:o,confirmationPromise:s}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let i=!1;const s=new Promise(t=>{const r=async()=>{try{const t=await this.getBlockHeight(e);return t}catch(t){return-1}};(async()=>{let e=await r();if(!i){while(e<=n){if(await ze(1e3),i)return;if(e=await r(),i)return}t({__type:de.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),c=this.getCancellationPromise(t);let u;try{const e=await Promise.race([c,a,s]);if(e.__type!==de.PROCESSED)throw new D(r);u=e.response}finally{i=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:i,signature:s}}){let o=!1;const a=new Promise(t=>{let s=i,a=null;const c=async()=>{try{const{context:t,value:i}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return a=t.slot,null===i||void 0===i?void 0:i.nonce}catch(t){return s}};(async()=>{if(s=await c(),!o)while(1){if(i!==s)return void t({__type:de.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await ze(2e3),o)return;if(s=await c(),o)return}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let d;try{const t=await Promise.race([l,u,a]);if(t.__type===de.PROCESSED)d=t.response;else{var h;let r;while(1){var b;const e=await this.getSignatureStatus(s);if(null==e)break;if(!(e.context.slot<(null!==(b=t.slotInWhichNonceDidAdvance)&&void 0!==b?b:n))){r=e;break}await ze(400)}if(null===(h=r)||void 0===h||!h.value)throw new F(s);{const t=e||"finalized",{confirmationStatus:n}=r.value;switch(t){case"processed":case"recent":if("processed"!==n&&"confirmed"!==n&&"finalized"!==n)throw new F(s);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==n&&"finalized"!==n)throw new F(s);break;case"finalized":case"max":case"root":if("finalized"!==n)throw new F(s);break;default:}d={context:r.context,value:{err:r.value.err}}}}}finally{o=!0,c()}return d}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const r=new Promise(t=>{let r=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":r=this._confirmTransactionInitialTimeout||3e4;break}n=setTimeout(()=>t({__type:de.TIMED_OUT,timeoutMs:r}),r)}),{abortConfirmation:i,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let o;try{const e=await Promise.race([s,r]);if(e.__type!==de.PROCESSED)throw new V(t,e.timeoutMs/1e3);o=e.response}finally{clearTimeout(n),i()}return o}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=d.create(e,It(d.array(In)));if("error"in t)throw new Ce(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=d.create(n,vn);if("error"in r)throw new Ce(r.error,"failed to get vote accounts");return r.result}async getSlot(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,void 0,n),i=await this._rpcRequest("getSlot",r),s=d.create(i,It(d.number()));if("error"in s)throw new Ce(s.error,"failed to get slot");return s.result}async getSlotLeader(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,void 0,n),i=await this._rpcRequest("getSlotLeader",r),s=d.create(i,It(d.string()));if("error"in s)throw new Ce(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,t){const n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),i=d.create(r,It(d.array(bt)));if("error"in i)throw new Ce(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(e,t){const{context:n,value:r}=await this.getSignatureStatuses([e],t);re(1===r.length);const i=r[0];return{context:n,value:i}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const r=await this._rpcRequest("getSignatureStatuses",n),i=d.create(r,En);if("error"in i)throw new Ce(i.error,"failed to get signature status");return i.result}async getTransactionCount(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,void 0,n),i=await this._rpcRequest("getTransactionCount",r),s=d.create(i,It(d.number()));if("error"in s)throw new Ce(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){const t=await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0});return t.value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=d.create(n,Vt);if("error"in r)throw new Ce(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){const{commitment:r,config:i}=yt(n),s=this._buildArgs([e.map(e=>e.toBase58())],r,void 0,{...i,epoch:null!=t?t:null===i||void 0===i?void 0:i.epoch}),o=await this._rpcRequest("getInflationReward",s),a=d.create(o,Et);if("error"in a)throw new Ce(a.error,"failed to get inflation reward");return a.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=d.create(e,Ft);if("error"in t)throw new Ce(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,void 0,n),i=await this._rpcRequest("getEpochInfo",r),s=d.create(i,$t);if("error"in s)throw new Ce(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=d.create(e,Gt);if("error"in t)throw new Ce(t.error,"failed to get epoch schedule");const n=t.result;return new it(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=d.create(e,Yt);if("error"in t)throw new Ce(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),i=d.create(r,Tn);return"error"in i?(console.warn("Unable to fetch minimum balance for rent exemption"),0):i.result}async getRecentBlockhashAndContext(e){const{context:t,value:{blockhash:n}}=await this.getLatestBlockhashAndContext(e),r={get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}};return{context:t,value:{blockhash:n,feeCalculator:r}}}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=d.create(t,ir);if("error"in n)throw new Ce(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),i=d.create(r,sr);if("error"in i)throw new Ce(i.error,"failed to get fee calculator");const{context:s,value:o}=i.result;return{context:s,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(e,t){const n=T(e.serialize()).toString("base64"),r=this._buildArgs([n],t),i=await this._rpcRequest("getFeeForMessage",r),s=d.create(i,At(d.nullable(d.number())));if("error"in s)throw new Ce(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){var t;const n=null===e||void 0===e||null===(t=e.lockedWritableAccounts)||void 0===t?void 0:t.map(e=>e.toBase58()),r=null!==n&&void 0!==n&&n.length?[n]:[],i=await this._rpcRequest("getRecentPrioritizationFees",r),s=d.create(i,Ht);if("error"in s)throw new Ce(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{const t=await this.getRecentBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{const t=await this.getLatestBlockhashAndContext(e);return t.value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,void 0,n),i=await this._rpcRequest("getLatestBlockhash",r),s=d.create(i,tr);if("error"in s)throw new Ce(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgs([e],n,void 0,r),s=await this._rpcRequest("isBlockhashValid",i),o=d.create(s,nr);if("error"in o)throw new Ce(o.error,"failed to determine if the blockhash `"+e+"`is valid");return o.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=d.create(e,It(Nt));if("error"in t)throw new Ce(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=d.create(e,It(d.string()));if("error"in t)throw new Ce(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgsAtLeastConfirmed([e],n,void 0,r),s=await this._rpcRequest("getBlock",i);try{switch(null===r||void 0===r?void 0:r.transactionDetails){case"accounts":{const e=d.create(s,$n);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Hn);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Fn);if("error"in e)throw e.error;const{result:t}=e;return t?{...t,transactions:t.transactions.map(({transaction:e,meta:t,version:n})=>({meta:t,transaction:{...e,message:_t(n,e.message)},version:n}))}:null}}}catch(o){throw new Ce(o,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),s=await this._rpcRequest("getBlock",i);try{switch(null===r||void 0===r?void 0:r.transactionDetails){case"accounts":{const e=d.create(s,Yn);if("error"in e)throw e.error;return e.result}case"none":{const e=d.create(s,Jn);if("error"in e)throw e.error;return e.result}default:{const e=d.create(s,Gn);if("error"in e)throw e.error;return e.result}}}catch(o){throw new Ce(o,"failed to get block")}}async getBlockProduction(e){let t,n;if("string"===typeof e)n=e;else if(e){const{commitment:r,...i}=e;n=r,t=i}const r=this._buildArgs([],n,"base64",t),i=await this._rpcRequest("getBlockProduction",r),s=d.create(i,Mt);if("error"in s)throw new Ce(s.error,"failed to get block production information");return s.result}async getTransaction(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgsAtLeastConfirmed([e],n,void 0,r),s=await this._rpcRequest("getTransaction",i),o=d.create(s,Qn);if("error"in o)throw new Ce(o.error,"failed to get transaction");const a=o.result;return a?{...a,transaction:{...a.transaction,message:_t(a.version,a.transaction.message)}}:a}async getParsedTransaction(e,t){const{commitment:n,config:r}=yt(t),i=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),s=await this._rpcRequest("getTransaction",i),o=d.create(s,er);if("error"in o)throw new Ce(o.error,"failed to get transaction");return o.result}async getParsedTransactions(e,t){const{commitment:n,config:r}=yt(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,er);if("error"in t)throw new Ce(t.error,"failed to get transactions");return t.result});return o}async getTransactions(e,t){const{commitment:n,config:r}=yt(t),i=e.map(e=>{const t=this._buildArgsAtLeastConfirmed([e],n,void 0,r);return{methodName:"getTransaction",args:t}}),s=await this._rpcBatchRequest(i),o=s.map(e=>{const t=d.create(e,Qn);if("error"in t)throw new Ce(t.error,"failed to get transactions");const n=t.result;return n?{...n,transaction:{...n.transaction,message:_t(n.version,n.transaction.message)}}:n});return o}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getBlock",n),i=d.create(r,Xn);if("error"in i)throw new Ce(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");const o={...s,transactions:s.transactions.map(({transaction:e,meta:t})=>{const n=new ce(e.message);return{meta:t,transaction:{...e,message:n}}})};return{...o,transactions:o.transactions.map(({transaction:e,meta:t})=>({meta:t,transaction:pe.populate(e.message,e.signatures)}))}}async getBlocks(e,t,n){const r=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],n),i=await this._rpcRequest("getBlocks",r),s=d.create(i,It(d.array(d.number())));if("error"in s)throw new Ce(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),i=d.create(r,Zn);if("error"in i)throw new Ce(i.error,"failed to get block");const s=i.result;if(!s)throw new Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),i=d.create(r,Zn);if("error"in i)throw new Ce(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getTransaction",n),i=d.create(r,Qn);if("error"in i)throw new Ce(i.error,"failed to get transaction");const s=i.result;if(!s)return s;const o=new ce(s.transaction.message),a=s.transaction.signatures;return{...s,transaction:pe.populate(o,a)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getTransaction",n),i=d.create(r,er);if("error"in i)throw new Ce(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(e,t){const n=e.map(e=>{const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed");return{methodName:"getTransaction",args:n}}),r=await this._rpcBatchRequest(n),i=r.map(e=>{const t=d.create(e,er);if("error"in t)throw new Ce(t.error,"failed to get confirmed transactions");return t.result});return i}async getConfirmedSignaturesForAddress(e,t,n){let r={},i=await this.getFirstAvailableBlock();while(!("until"in r)){if(t--,t<=0||t<i)break;try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(r.until=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}let s=await this.getSlot("finalized");while(!("before"in r)){if(n++,n>s)break;try{const e=await this.getConfirmedBlockSignatures(n);e.signatures.length>0&&(r.before=e.signatures[e.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}}const o=await this.getConfirmedSignaturesForAddress2(e,r);return o.map(e=>e.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),s=d.create(i,dn);if("error"in s)throw new Ce(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),i=await this._rpcRequest("getSignaturesForAddress",r),s=d.create(i,hn);if("error"in s)throw new Ce(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==r&&(i=new ut({key:e,state:ut.deserialize(r.data)})),{context:n,value:i}}async getNonceAndContext(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==r&&(i=Me.fromAccountData(r.data)),{context:n,value:i}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(e=>e.value).catch(t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=d.create(n,or);if("error"in r)throw new Ce(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){while(this._pollingBlockhash)await ze(100);const e=Date.now()-this._blockhashInfo.lastFetch,t=e>=mt;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){const e=await this.getLatestBlockhash("finalized");if(n!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await ze(we/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=yt(e),r=this._buildArgs([],t,"base64",n),i=await this._rpcRequest("getStakeMinimumDelegation",r),s=d.create(i,At(d.number()));if("error"in s)throw new Ce(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,t,n){if("message"in e){const i=e,s=i.serialize(),o=r.Buffer.from(s).toString("base64");if(Array.isArray(t)||void 0!==n)throw new Error("Invalid arguments");const a=t||{};a.encoding="base64","commitment"in a||(a.commitment=this.commitment),t&&"object"===typeof t&&"innerInstructions"in t&&(a.innerInstructions=t.innerInstructions);const c=[o,a],u=await this._rpcRequest("simulateTransaction",c),l=d.create(u,jt);if("error"in l)throw new Error("failed to simulate transaction: "+l.error.message);return l.result}let i;if(e instanceof pe){let t=e;i=new pe,i.feePayer=t.feePayer,i.instructions=e.instructions,i.nonceInfo=t.nonceInfo,i.signatures=t.signatures}else i=pe.populate(e),i._message=i._json=void 0;if(void 0!==t&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(i.nonceInfo&&s)i.sign(...s);else{let e=this._disableBlockhashCaching;for(;;){const t=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=t.lastValidBlockHeight,i.recentBlockhash=t.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const n=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(n)&&!this._blockhashInfo.transactionSignatures.includes(n)){this._blockhashInfo.simulatedSignatures.push(n);break}e=!0}}const o=i._compile(),a=o.serialize(),c=i._serialize(a),u=c.toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const e=(Array.isArray(n)?n:o.nonProgramIds()).map(e=>e.toBase58());l["accounts"]={encoding:"base64",addresses:e}}s&&(l.sigVerify=!0),t&&"object"===typeof t&&"innerInstructions"in t&&(l.innerInstructions=t.innerInstructions);const h=[u,l],b=await this._rpcRequest("simulateTransaction",h),p=d.create(b,jt);if("error"in p){let e;if("data"in p.error&&(e=p.error.data.logs,e&&Array.isArray(e))){const t="\n    ",n=t+e.join(t);console.error(p.error.message,n)}throw new Be({action:"simulate",signature:"",transactionMessage:p.error.message,logs:e})}return p.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const n=e.serialize();return await this.sendRawTransaction(n,t)}if(void 0===t||!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(e.nonceInfo)e.sign(...r);else{let t=this._disableBlockhashCaching;for(;;){const n=await this._blockhashWithExpiryBlockHeight(t);if(e.lastValidBlockHeight=n.lastValidBlockHeight,e.recentBlockhash=n.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");const i=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(i)){this._blockhashInfo.transactionSignatures.push(i);break}t=!0}}const i=e.serialize();return await this.sendRawTransaction(i,n)}async sendRawTransaction(e,t){const n=T(e).toString("base64"),r=await this.sendEncodedTransaction(n,t);return r}async sendEncodedTransaction(e,t){const n={encoding:"base64"},r=t&&t.skipPreflight,i=!0===r?"processed":t&&t.preflightCommitment||this.commitment;t&&null!=t.maxRetries&&(n.maxRetries=t.maxRetries),t&&null!=t.minContextSlot&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),i&&(n.preflightCommitment=i);const s=[e,n],o=await this._rpcRequest("sendTransaction",s),a=d.create(o,ar);if("error"in a){let e=void 0;throw"data"in a.error&&(e=a.error.data.logs),new Be({action:r?"send":"simulate",signature:"",transactionMessage:a.error.message,logs:e})}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,t])=>{this._setSubscription(e,{...t,state:"pending"})})):this._updateSubscriptions()}_setSubscription(e,t){var n;const r=null===(n=this._subscriptionsByHash[e])||void 0===n?void 0:n.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach(e=>{try{e(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var n;const r=this._subscriptionHashByClientSubscriptionId[e];if(null==r)return()=>{};const i=(n=this._subscriptionStateChangeCallbacksByHash)[r]||(n[r]=new Set);return i.add(t),()=>{i.delete(t),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){e instanceof Error&&console.log("Error when closing socket connection: "+e.message)}},500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async e=>{const n=this._subscriptionsByHash[e];if(void 0!==n)switch(n.state){case"pending":case"unsubscribed":if(0===n.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===n.state&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:r,method:i}=n;try{this._setSubscription(e,{...n,state:"subscribing"});const t=await this._rpcWebSocket.call(i,r);this._setSubscription(e,{...n,serverSubscriptionId:t,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[t]=n.callbacks,await this._updateSubscriptions()}catch(s){if(console.error(`Received ${s instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:r,error:s}),!t())return;this._setSubscription(e,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===n.callbacks.size&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:i}=n;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(e,{...n,state:"unsubscribing"}),this._setSubscription(e,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[r])}catch(s){if(s instanceof Error&&console.error(i+" error:",s.message),!t())return;return this._setSubscription(e,{...n,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==n&&n.forEach(e=>{try{e(...t)}catch(n){console.error(n)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=d.create(e,bn);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,r=et([e.method,t]),i=this._subscriptionsByHash[r];return void 0===i?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:i.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const t=this._subscriptionsByHash[r];re(void 0!==t,"Could not find a `Subscription` when tearing down client subscription #"+n),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:r,config:i}=yt(n),s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",i);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=d.create(e,gn);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){const{commitment:i,config:s}=yt(n),o=this._buildArgs([e.toBase58()],i||this._commitment||"finalized","base64",s||(r?{filters:kt(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const r=this._buildArgs(["object"===typeof e?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=d.create(e,ur);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=d.create(e,fn);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=d.create(e,kn);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){const i=t||this._commitment;if(i||n||r){let t={};n&&(t.encoding=n),i&&(t.commitment=i),r&&(t=Object.assign(t,r)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){const i=t||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=d.create(e,wn);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const r=this._buildArgs([e],n||this._commitment||"finalized"),i=this._makeSubscription({callback:(e,n)=>{if("status"===e.type){t(e.result,n);try{this.removeSignatureListener(i)}catch(r){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return i}onSignatureWithOptions(e,t,n){const{commitment:r,...i}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},s=this._buildArgs([e],r,void 0,i),o=this._makeSubscription({callback:(e,n)=>{t(e,n);try{this.removeSignatureListener(o)}catch(r){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=d.create(e,Sn);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class hr{constructor(e){this._keypair=void 0,this._keypair=null!==e&&void 0!==e?e:A()}static generate(){return new hr(A())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),r=v(t);for(let e=0;e<32;e++)if(n[e]!==r[e])throw new Error("provided secretKey is invalid")}return new hr({publicKey:n,secretKey:e})}static fromSeed(e){const t=v(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new hr({publicKey:t,secretKey:n})}get publicKey(){return new K(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const br=Object.freeze({CreateLookupTable:{index:0,layout:w.struct([w.u32("instruction"),Ue("recentSlot"),w.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:w.struct([w.u32("instruction")])},ExtendLookupTable:{index:2,layout:w.struct([w.u32("instruction"),Ue(),w.seq($(),w.offset(w.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:w.struct([w.u32("instruction")])},CloseLookupTable:{index:4,layout:w.struct([w.u32("instruction")])}});class pr{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=w.u32("instruction"),n=t.decode(e.data);let r;for(const[i,s]of Object.entries(br))if(s.index==n){r=i;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=Ne(br.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=Ne(br.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(e=>new K(e))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(gr.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class gr{constructor(){}static createLookupTable(e){const[t,n]=K.findProgramAddressSync([e.authority.toBuffer(),l.getU64Encoder().encode(e.recentSlot)],this.programId),r=br.CreateLookupTable,i=Le(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ve.programId,isSigner:!1,isWritable:!1}];return[new be({programId:this.programId,keys:s,data:i}),t]}static freezeLookupTable(e){const t=br.FreezeLookupTable,n=Le(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new be({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){const t=br.ExtendLookupTable,n=Le(t,{addresses:e.addresses.map(e=>e.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ve.programId,isSigner:!1,isWritable:!1}),new be({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){const t=br.DeactivateLookupTable,n=Le(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new be({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){const t=br.CloseLookupTable,n=Le(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new be({programId:this.programId,keys:r,data:n})}}gr.programId=new K("AddressLookupTab1e1111111111111111111111111");class mr{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=w.u8("instruction"),n=t.decode(e.data);let r;for(const[i,s]of Object.entries(fr))if(s.index==n){r=i;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=Ne(fr.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=Ne(fr.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=Ne(fr.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=Ne(fr.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(yr.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const fr=Object.freeze({RequestUnits:{index:0,layout:w.struct([w.u8("instruction"),w.u32("units"),w.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:w.struct([w.u8("instruction"),w.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:w.struct([w.u8("instruction"),w.u32("units")])},SetComputeUnitPrice:{index:3,layout:w.struct([w.u8("instruction"),Ue("microLamports")])}});class yr{constructor(){}static requestUnits(e){const t=fr.RequestUnits,n=Le(t,e);return new be({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=fr.RequestHeapFrame,n=Le(t,e);return new be({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=fr.SetComputeUnitLimit,n=Le(t,e);return new be({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=fr.SetComputeUnitPrice,n=Le(t,{microLamports:BigInt(e.microLamports)});return new be({keys:[],programId:this.programId,data:n})}}yr.programId=new K("ComputeBudget111111111111111111111111111111");const kr=64,wr=32,Sr=64,Ir=w.struct([w.u8("numSignatures"),w.u8("padding"),w.u16("signatureOffset"),w.u16("signatureInstructionIndex"),w.u16("publicKeyOffset"),w.u16("publicKeyInstructionIndex"),w.u16("messageDataOffset"),w.u16("messageDataSize"),w.u16("messageInstructionIndex")]);class Ar{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:i,instructionIndex:s}=e;re(t.length===wr,`Public Key must be ${wr} bytes but received ${t.length} bytes`),re(i.length===Sr,`Signature must be ${Sr} bytes but received ${i.length} bytes`);const o=Ir.span,a=o+t.length,c=a+i.length,u=1,l=r.Buffer.alloc(c+n.length),d=null==s?65535:s;return Ir.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:d},l),l.fill(t,o),l.fill(i,a),l.fill(n,c),new be({keys:[],programId:Ar.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;re(t.length===kr,`Private key must be ${kr} bytes but received ${t.length} bytes`);try{const e=hr.fromSecretKey(t),i=e.publicKey.toBytes(),s=P(n,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:s,instructionIndex:r})}catch(i){throw new Error("Error creating instruction; "+i)}}}Ar.programId=new K("Ed25519SigVerify111111111111111111111111111");const vr=(e,t)=>{const n=g.secp256k1.sign(e,t);return[n.toCompactRawBytes(),n.recovery]};g.secp256k1.utils.isValidPrivateKey;const _r=g.secp256k1.getPublicKey,Pr=32,Er=20,Tr=64,Or=11,Br=w.struct([w.u8("numSignatures"),w.u16("signatureOffset"),w.u8("signatureInstructionIndex"),w.u16("ethAddressOffset"),w.u8("ethAddressInstructionIndex"),w.u16("messageDataOffset"),w.u16("messageDataSize"),w.u8("messageInstructionIndex"),w.blob(20,"ethAddress"),w.blob(64,"signature"),w.u8("recoveryId")]);class xr{constructor(){}static publicKeyToEthAddress(e){re(e.length===Tr,`Public key must be ${Tr} bytes but received ${e.length} bytes`);try{return r.Buffer.from(p.keccak_256(T(e))).slice(-Er)}catch(t){throw new Error("Error constructing Ethereum address: "+t)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,recoveryId:i,instructionIndex:s}=e;return xr.createInstructionWithEthAddress({ethAddress:xr.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:i,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"===typeof t?t.startsWith("0x")?r.Buffer.from(t.substr(2),"hex"):r.Buffer.from(t,"hex"):t,re(a.length===Er,`Address must be ${Er} bytes but received ${a.length} bytes`);const c=1+Or,u=c,l=c+a.length,d=l+i.length+1,h=1,b=r.Buffer.alloc(Br.span+n.length);return Br.encode({numSignatures:h,signatureOffset:l,signatureInstructionIndex:o,ethAddressOffset:u,ethAddressInstructionIndex:o,messageDataOffset:d,messageDataSize:n.length,messageInstructionIndex:o,signature:T(i),ethAddress:T(a),recoveryId:s},b),b.fill(T(n),Br.span),new be({keys:[],programId:xr.programId,data:b})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:i}=e;re(t.length===Pr,`Private key must be ${Pr} bytes but received ${t.length} bytes`);try{const e=T(t),s=_r(e,!1).slice(1),o=r.Buffer.from(p.keccak_256(T(n))),[a,c]=vr(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:n,signature:a,recoveryId:c,instructionIndex:i})}catch(s){throw new Error("Error creating instruction; "+s)}}}var Cr;xr.programId=new K("KeccakSecp256k11111111111111111111111111111");const Rr=new K("StakeConfig11111111111111111111111111111111");class zr{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class Lr{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Cr=Lr,Lr.default=new Cr(0,0,K.default);class Nr{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=w.u32("instruction"),n=t.decode(e.data);let r;for(const[i,s]of Object.entries(Kr))if(s.index==n){r=i;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=Ne(Kr.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new zr(new K(t.staker),new K(t.withdrawer)),lockup:new Lr(n.unixTimestamp,n.epoch,new K(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),Ne(Kr.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=Ne(Kr.Authorize,e.data),r={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new K(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(r.custodianPubkey=e.keys[3].pubkey),r}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:r,authorityOwner:i}=Ne(Kr.AuthorizeWithSeed,e.data),s={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:r,authorityOwner:new K(i),newAuthorizedPubkey:new K(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Ne(Kr.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Ne(Kr.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Ne(Kr.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Ne(Kr.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(jr.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Kr=Object.freeze({Initialize:{index:0,layout:w.struct([w.u32("instruction"),J(),X()])},Authorize:{index:1,layout:w.struct([w.u32("instruction"),$("newAuthorized"),w.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:w.struct([w.u32("instruction")])},Split:{index:3,layout:w.struct([w.u32("instruction"),w.ns64("lamports")])},Withdraw:{index:4,layout:w.struct([w.u32("instruction"),w.ns64("lamports")])},Deactivate:{index:5,layout:w.struct([w.u32("instruction")])},Merge:{index:7,layout:w.struct([w.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:w.struct([w.u32("instruction"),$("newAuthorized"),w.u32("stakeAuthorizationType"),Y("authoritySeed"),$("authorityOwner")])}}),Wr=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class jr{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:r}=e,i=r||Lr.default,s=Kr.Initialize,o=Le(s,{authorized:{staker:T(n.staker.toBuffer()),withdrawer:T(n.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:T(i.custodian.toBuffer())}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new be(a)}static createAccountWithSeed(e){const t=new pe;t.add(Ve.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:i}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:i}))}static createAccount(e){const t=new pe;t.add(Ve.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:i}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,i=Kr.Delegate,s=Le(i);return(new pe).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Rr,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:i,custodianPubkey:s}=e,o=Kr.Authorize,a=Le(o,{newAuthorized:T(r.toBuffer()),stakeAuthorizationType:i.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new pe).add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,c=Kr.AuthorizeWithSeed,u=Le(c,{newAuthorized:T(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:r,authorityOwner:T(i.toBuffer())}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1}];return a&&l.push({pubkey:a,isSigner:!0,isWritable:!1}),(new pe).add({keys:l,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:i}=e,s=Kr.Split,o=Le(s,{lamports:i});return new be({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static split(e,t){const n=new pe;return n.add(Ve.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,c=new pe;return c.add(Ve.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&c.add(Ve.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),c.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,i=Kr.Merge,s=Le(i);return(new pe).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:i,custodianPubkey:s}=e,o=Kr.Withdraw,a=Le(o,{lamports:i}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return s&&c.push({pubkey:s,isSigner:!0,isWritable:!1}),(new pe).add({keys:c,programId:this.programId,data:a})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,r=Kr.Deactivate,i=Le(r);return(new pe).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}jr.programId=new K("Stake11111111111111111111111111111111111111"),jr.space=200;class Mr{constructor(e,t,n,r){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=r}}class Ur{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=w.u32("instruction"),n=t.decode(e.data);let r;for(const[i,s]of Object.entries(qr))if(s.index==n){r=i;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=Ne(qr.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Mr(new K(t.nodePubkey),new K(t.authorizedVoter),new K(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=Ne(qr.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new K(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:r,voteAuthorizationType:i}}=Ne(qr.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new K(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new K(r),voteAuthorizationType:{index:i},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Ne(qr.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Vr.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const qr=Object.freeze({InitializeAccount:{index:0,layout:w.struct([w.u32("instruction"),Z()])},Authorize:{index:1,layout:w.struct([w.u32("instruction"),$("newAuthorized"),w.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:w.struct([w.u32("instruction"),w.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:w.struct([w.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:w.struct([w.u32("instruction"),Q()])}}),Dr=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Vr{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:r}=e,i=qr.InitializeAccount,s=Le(i,{voteInit:{nodePubkey:T(r.nodePubkey.toBuffer()),authorizedVoter:T(r.authorizedVoter.toBuffer()),authorizedWithdrawer:T(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new be(o)}static createAccount(e){const t=new pe;return t.add(Ve.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:i}=e,s=qr.Authorize,o=Le(s,{newAuthorized:T(r.toBuffer()),voteAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new pe).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=qr.AuthorizeWithSeed,c=Le(a,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:T(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:T(i.toBuffer()),voteAuthorizationType:s.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new pe).add({keys:u,programId:this.programId,data:c})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:i}=e,s=qr.Withdraw,o=Le(s,{lamports:r}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return(new pe).add({keys:a,programId:this.programId,data:o})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return Vr.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,i=qr.UpdateValidatorIdentity,s=Le(i),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new pe).add({keys:o,programId:this.programId,data:s})}}Vr.programId=new K("Vote111111111111111111111111111111111111111"),Vr.space=3762;const Fr=new K("Va1idator1nfo111111111111111111111111111111"),Hr=d.type({name:d.string(),website:d.optional(d.string()),details:d.optional(d.string()),iconUrl:d.optional(d.string()),keybaseUsername:d.optional(d.string())});class $r{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];const n=te(t);if(2!==n)return null;const i=[];for(let r=0;r<2;r++){const e=new K(ae(t,0,z)),n=1===oe(t);i.push({publicKey:e,isSigner:n})}if(i[0].publicKey.equals(Fr)&&i[1].isSigner){const e=Y().decode(r.Buffer.from(t)),n=JSON.parse(e);return d.assert(n,Hr),new $r(i[1].publicKey,n)}return null}}const Gr=new K("Vote111111111111111111111111111111111111111"),Yr=w.struct([$("nodePubkey"),$("authorizedWithdrawer"),w.u8("commission"),w.nu64(),w.seq(w.struct([w.nu64("slot"),w.u32("confirmationCount")]),w.offset(w.u32(),-8),"votes"),w.u8("rootSlotValid"),w.nu64("rootSlot"),w.nu64(),w.seq(w.struct([w.nu64("epoch"),$("authorizedVoter")]),w.offset(w.u32(),-8),"authorizedVoters"),w.struct([w.seq(w.struct([$("authorizedPubkey"),w.nu64("epochOfLastAuthorizedSwitch"),w.nu64("targetEpoch")]),32,"buf"),w.nu64("idx"),w.u8("isEmpty")],"priorVoters"),w.nu64(),w.seq(w.struct([w.nu64("epoch"),w.nu64("credits"),w.nu64("prevCredits")]),w.offset(w.u32(),-8),"epochCredits"),w.struct([w.nu64("slot"),w.nu64("timestamp")],"lastTimestamp")]);class Jr{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const t=4,n=Yr.decode(T(e),t);let r=n.rootSlot;return n.rootSlotValid||(r=null),new Jr({nodePubkey:new K(n.nodePubkey),authorizedWithdrawer:new K(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:r,authorizedVoters:n.authorizedVoters.map(Xr),priorVoters:Qr(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function Xr({authorizedVoter:e,epoch:t}){return{epoch:t,authorizedVoter:new K(e)}}function Zr({authorizedPubkey:e,epochOfLastAuthorizedSwitch:t,targetEpoch:n}){return{authorizedPubkey:new K(e),epochOfLastAuthorizedSwitch:t,targetEpoch:n}}function Qr({buf:e,idx:t,isEmpty:n}){return n?[]:[...e.slice(t+1).map(Zr),...e.slice(0,t).map(Zr)]}const ei={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function ti(e,t){const n=!1===t?"http":"https";if(!e)return ei[n]["devnet"];const r=ei[n][e];if(!r)throw new Error(`Unknown ${n} cluster: ${e}`);return r}async function ni(e,t,n,r){let i,s;n&&Object.prototype.hasOwnProperty.call(n,"lastValidBlockHeight")||n&&Object.prototype.hasOwnProperty.call(n,"nonceValue")?(i=n,s=r):s=n;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},a=await e.sendRawTransaction(t,o),c=s&&s.commitment,u=i?e.confirmTransaction(i,c):e.confirmTransaction(a,c),l=(await u).value;if(l.err){if(null!=a)throw new Be({action:null!==o&&void 0!==o&&o.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(l)})`});throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`)}return a}const ri=1e9;t.Account=W,t.AddressLookupTableAccount=ut,t.AddressLookupTableInstruction=pr,t.AddressLookupTableProgram=gr,t.Authorized=zr,t.BLOCKHASH_CACHE_TIMEOUT_MS=mt,t.BPF_LOADER_DEPRECATED_PROGRAM_ID=j,t.BPF_LOADER_PROGRAM_ID=$e,t.BpfLoader=Ge,t.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=fr,t.ComputeBudgetInstruction=mr,t.ComputeBudgetProgram=yr,t.Connection=dr,t.Ed25519Program=Ar,t.Enum=B,t.EpochSchedule=it,t.FeeCalculatorLayout=Ke,t.Keypair=hr,t.LAMPORTS_PER_SOL=ri,t.LOOKUP_TABLE_INSTRUCTION_LAYOUTS=br,t.Loader=He,t.Lockup=Lr,t.MAX_SEED_LENGTH=R,t.Message=ce,t.MessageAccountKeys=H,t.MessageV0=ue,t.NONCE_ACCOUNT_LENGTH=je,t.NonceAccount=Me,t.PACKET_DATA_SIZE=M,t.PUBLIC_KEY_LENGTH=z,t.PublicKey=K,t.SIGNATURE_LENGTH_IN_BYTES=q,t.SOLANA_SCHEMA=x,t.STAKE_CONFIG_ID=Rr,t.STAKE_INSTRUCTION_LAYOUTS=Kr,t.SYSTEM_INSTRUCTION_LAYOUTS=De,t.SYSVAR_CLOCK_PUBKEY=Se,t.SYSVAR_EPOCH_SCHEDULE_PUBKEY=Ie,t.SYSVAR_INSTRUCTIONS_PUBKEY=Ae,t.SYSVAR_RECENT_BLOCKHASHES_PUBKEY=ve,t.SYSVAR_RENT_PUBKEY=_e,t.SYSVAR_REWARDS_PUBKEY=Pe,t.SYSVAR_SLOT_HASHES_PUBKEY=Ee,t.SYSVAR_SLOT_HISTORY_PUBKEY=Te,t.SYSVAR_STAKE_HISTORY_PUBKEY=Oe,t.Secp256k1Program=xr,t.SendTransactionError=Be,t.SolanaJSONRPCError=Ce,t.SolanaJSONRPCErrorCode=xe,t.StakeAuthorizationLayout=Wr,t.StakeInstruction=Nr,t.StakeProgram=jr,t.Struct=O,t.SystemInstruction=qe,t.SystemProgram=Ve,t.Transaction=pe,t.TransactionExpiredBlockheightExceededError=D,t.TransactionExpiredNonceInvalidError=F,t.TransactionExpiredTimeoutError=V,t.TransactionInstruction=be,t.TransactionMessage=ge,t.TransactionStatus=de,t.VALIDATOR_INFO_KEY=Fr,t.VERSION_PREFIX_MASK=U,t.VOTE_PROGRAM_ID=Gr,t.ValidatorInfo=$r,t.VersionedMessage=le,t.VersionedTransaction=me,t.VoteAccount=Jr,t.VoteAuthorizationLayout=Dr,t.VoteInit=Mr,t.VoteInstruction=Ur,t.VoteProgram=Vr,t.clusterApiUrl=ti,t.sendAndConfirmRawTransaction=ni,t.sendAndConfirmTransaction=Re},"0f06":function(e,t,n){"use strict";(function(e){n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return a}));n("e9f5"),n("ab43");var r,i=n("8df2"),s=n("633a");n("d6e3"),n("753b"),n("d99e"),n("7f6a"),n("f7f2");(function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["Initialized"]=1]="Initialized",e[e["Frozen"]=2]="Frozen"})(r||(r={}));const o=Object(i["struct"])([Object(s["b"])("mint"),Object(s["b"])("owner"),Object(s["c"])("amount"),Object(i["u32"])("delegateOption"),Object(s["b"])("delegate"),Object(i["u8"])("state"),Object(i["u32"])("isNativeOption"),Object(s["c"])("isNative"),Object(s["c"])("delegatedAmount"),Object(i["u32"])("closeAuthorityOption"),Object(s["b"])("closeAuthority")]),a=o.span}).call(this,n("1c35").Buffer)},"17fd":function(e,t,n){"use strict";(function(e){n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return c}));var r=n("8df2"),i=(n("7f6a"),n("64b9"),n("633a"));n("753b"),n("7b05");const s=Object(r["struct"])([Object(i["b"])("authority"),Object(i["b"])("programId")]),o=s.span;const a=Object(r["struct"])([Object(i["a"])("transferring")]),c=a.span;const u=Object(r["struct"])([Object(r["u8"])("discriminator"),Object(r["blob"])(32,"addressConfig"),Object(i["a"])("isSigner"),Object(i["a"])("isWritable")]),l=Object(r["struct"])([Object(r["u32"])("count"),Object(r["seq"])(u,Object(r["greedy"])(u.span),"extraAccounts")]);Object(r["struct"])([Object(i["c"])("instructionDiscriminator"),Object(r["u32"])("length"),l.replicate("extraAccountsList")])}).call(this,n("1c35").Buffer)},"1bd0":function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return l}));var r=n("8df2"),i=n("633a"),s=n("64b9"),o=n("d6e3"),a=(n("753b"),n("abed")),c=n("fbe3");const u=Object(r["struct"])([Object(r["u8"])("instruction"),Object(i["c"])("amount")]);function l(t,n,r,i,l=[],d=o["c"]){const h=Object(a["a"])([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0}],r,l),b=e.alloc(u.span);return u.encode({instruction:c["a"].Transfer,amount:BigInt(i)},b),new s["g"]({keys:h,programId:d,data:b})}}).call(this,n("1c35").Buffer)},"22d8":function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return c}));var r=n("8df2"),i=n("64b9"),s=n("d6e3"),o=(n("753b"),n("fbe3"));const a=Object(r["struct"])([Object(r["u8"])("instruction")]);function c(t,n,r,c=s["c"]){const u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i["d"],isSigner:!1,isWritable:!1}],l=e.alloc(a.span);return a.encode({instruction:o["a"].InitializeAccount},l),new i["g"]({keys:u,programId:c,data:l})}}).call(this,n("1c35").Buffer)},"3ecc":function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return h}));n("2c66"),n("249d"),n("40e9"),n("e9f5"),n("ab43"),n("9547"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1");var r=n("d6e3"),i=n("0f06"),s=n("22d8"),o=n("1bd0"),a=n("64b9"),c=n("399f"),u=n.n(c),l=n("a8d6");const d=new a["b"](Object({NODE_ENV:"production",BASE_URL:"/"}).VUE_APP_SOLANA_RPC_URL||"http://localhost:8899","confirmed"),h=async(t,n,c,h,b,p)=>{const g=new a["c"](n),m=new a["c"]((await d.getParsedAccountInfo(g,"singleGossip")).value.data.parsed.info.mint),f=t.split(",").map(e=>parseInt(e)),y=new a["a"](f),k=new a["a"],w=a["e"].createAccount({programId:r["c"],space:i["b"].span,lamports:await d.getMinimumBalanceForRentExemption(i["b"].span,"singleGossip"),fromPubkey:y.publicKey,newAccountPubkey:k.publicKey}),S=Object(s["a"])(k.publicKey,m,y.publicKey,r["c"]),I=Object(o["a"])(g,k.publicKey,y.publicKey,c,[],r["c"]),A=new a["a"],v=new a["c"](p),_=a["e"].createAccount({space:l["a"].span,lamports:await d.getMinimumBalanceForRentExemption(l["a"].span,"singleGossip"),fromPubkey:y.publicKey,newAccountPubkey:A.publicKey,programId:v}),P=new a["g"]({programId:v,keys:[{pubkey:y.publicKey,isSigner:!0,isWritable:!1},{pubkey:k.publicKey,isSigner:!1,isWritable:!0},{pubkey:new a["c"](h),isSigner:!1,isWritable:!1},{pubkey:A.publicKey,isSigner:!1,isWritable:!0},{pubkey:a["d"],isSigner:!1,isWritable:!1},{pubkey:r["c"],isSigner:!1,isWritable:!1}],data:e.from(Uint8Array.of(0,...new u.a(b).toArray("le",8)))}),E=(new a["f"]).add(w,S,I,_,P);await d.sendTransaction(E,[y,k,A],{skipPreflight:!1,preflightCommitment:"singleGossip"}),await new Promise(e=>setTimeout(e,1e3));const T=(await d.getAccountInfo(A.publicKey,"singleGossip")).data,O=l["a"].decode(T);return{escrowAccountPubkey:A.publicKey.toBase58(),isInitialized:!!O.isInitialized,initializerAccountPubkey:new a["c"](O.initializerPubkey).toBase58(),XTokenTempAccountPubkey:new a["c"](O.initializerTempTokenAccountPubkey).toBase58(),initializerYTokenAccount:new a["c"](O.initializerReceivingTokenAccountPubkey).toBase58(),expectedAmount:new u.a(O.expectedAmount,10,"le").toNumber()}}}).call(this,n("1c35").Buffer)},"633a":function(e,t,n){"use strict";n.d(t,"c",(function(){return i["b"]})),n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return l}));var r=n("bbae"),i=n("a81a"),s=n("901e6"),o=n.n(s);new o.a("1e+18");var a=n("8df2");const c=e=>{const t=Object(a["u8"])(e),{encode:n,decode:i}=Object(r["a"])(t),s=t;return s.decode=(e,t)=>{const n=i(e,t);return!!n},s.encode=(e,t,r)=>{const i=Number(e);return n(i,t,r)},s};var u=n("0276");const l=e=>{const t=Object(a["blob"])(32,e),{encode:n,decode:i}=Object(r["a"])(t),s=t;return s.decode=(e,t)=>{const n=i(e,t);return new u["PublicKey"](n)},s.encode=(e,t,r)=>{const i=e.toBuffer();return n(i,t,r)},s}},"6baa":function(e,t,n){"use strict";n.r(t);var r=n("7a23");const i={class:"bg"},s={class:"mb-1"},o=["disabled"],a={class:"mb-1"},c=["disabled"],u={class:"mb-1"},l=["disabled"],d={class:"mb-1"},h=["disabled"],b={class:"mb-1"},p=["disabled"],g={class:"mb-1"},m=["disabled"],f={class:"mb-1"},y=["disabled"],k=["disabled"],w={key:0,style:{"margin-left":"10px"}},S={key:0,class:"mb-1 error-message"},I={key:1,class:"mb-1 success-message"},A={class:"mb-1"},v={class:"mb-1"},_={class:"mb-1"},P={class:"mb-1"},E={class:"mb-1"},T={class:"mb-1"};function O(e,t,n,O,B,x){var C,R,z,L,N,K;return Object(r["p"])(),Object(r["d"])("div",i,[t[22]||(t[22]=Object(r["e"])("p",{class:"title"},"Escrow UI",-1)),Object(r["e"])("div",null,[Object(r["e"])("div",s,[t[9]||(t[9]=Object(r["e"])("label",{for:"alice-private-key"},"Throwaway private key (as byte array from sollet.io, without the '[]')",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"text",id:"alice-private-key","onUpdate:modelValue":t[0]||(t[0]=t=>e.formState.privateKey=t),placeholder:"e.g. 1,2,3,...",disabled:e.loading},null,8,o),[[r["y"],e.formState.privateKey]])]),Object(r["e"])("div",a,[t[10]||(t[10]=Object(r["e"])("label",{for:"alice-program-id"},"Program id",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"text",id:"alice-program-id","onUpdate:modelValue":t[1]||(t[1]=t=>e.formState.programId=t),placeholder:"Program ID",disabled:e.loading},null,8,c),[[r["y"],e.formState.programId]])]),Object(r["e"])("div",u,[t[11]||(t[11]=Object(r["e"])("label",{for:"alice-x-token-acc"},"Alice's X token account pubkey",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"text",id:"alice-x-token-acc","onUpdate:modelValue":t[2]||(t[2]=t=>e.formState.aliceXTokenAccountPubkey=t),placeholder:"X Token Account Pubkey",disabled:e.loading},null,8,l),[[r["y"],e.formState.aliceXTokenAccountPubkey]])]),Object(r["e"])("div",d,[t[12]||(t[12]=Object(r["e"])("label",{for:"alice-x-token-amount"},"Amount of X tokens to send to escrow",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"number",id:"alice-x-token-amount","onUpdate:modelValue":t[3]||(t[3]=t=>e.formState.amountXTokensToSendToEscrow=t),placeholder:"Amount to send",min:"0",disabled:e.loading},null,8,h),[[r["y"],e.formState.amountXTokensToSendToEscrow]])]),Object(r["e"])("div",b,[t[13]||(t[13]=Object(r["e"])("label",{for:"alice-y-token-acc"},"Alice's Y token account pubkey",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"text",id:"alice-y-token-acc","onUpdate:modelValue":t[4]||(t[4]=t=>e.formState.aliceYTokenAccountPubkey=t),placeholder:"Y Token Account Pubkey",disabled:e.loading},null,8,p),[[r["y"],e.formState.aliceYTokenAccountPubkey]])]),Object(r["e"])("div",g,[t[14]||(t[14]=Object(r["e"])("label",{for:"alice-y-token-amount"},"Amount of Y tokens Alice wants",-1)),Object(r["B"])(Object(r["e"])("input",{class:"display-block",type:"number",id:"alice-y-token-amount","onUpdate:modelValue":t[5]||(t[5]=t=>e.formState.amountYTokensAliceExpects=t),placeholder:"Amount expected",min:"0",disabled:e.loading},null,8,m),[[r["y"],e.formState.amountYTokensAliceExpects]])]),Object(r["e"])("div",f,[Object(r["e"])("input",{style:{"margin-right":"5px"},class:"cursor-pointer border-none bg-btn normal-font-size",type:"button",value:"Reset UI",onClick:t[6]||(t[6]=(...t)=>e.resetAliceUI&&e.resetAliceUI(...t)),disabled:e.loading},null,8,y),Object(r["e"])("input",{class:"cursor-pointer border-none bg-btn normal-font-size",type:"button",value:"Init escrow",onClick:t[7]||(t[7]=(...t)=>e.onInitEscrow&&e.onInitEscrow(...t)),disabled:!e.isFormValid||e.loading},null,8,k),e.loading?(Object(r["p"])(),Object(r["d"])("span",w,"Initializing escrow...")):Object(r["c"])("",!0)]),e.errorMessage?(Object(r["p"])(),Object(r["d"])("div",S,Object(r["w"])(e.errorMessage),1)):Object(r["c"])("",!0),e.successMessage?(Object(r["p"])(),Object(r["d"])("div",I,Object(r["w"])(e.successMessage),1)):Object(r["c"])("",!0)]),Object(r["e"])("div",null,[Object(r["e"])("div",A,[t[15]||(t[15]=Object(r["f"])(" Escrow account: ")),Object(r["e"])("div",null,[Object(r["f"])(Object(r["w"])(null!==(C=e.escrowState.escrowAccountPubkey)&&void 0!==C?C:"--")+" ",1),e.escrowState.escrowAccountPubkey?(Object(r["p"])(),Object(r["d"])("button",{key:0,onClick:t[8]||(t[8]=(...t)=>e.copyEscrowPubkey&&e.copyEscrowPubkey(...t)),style:{"margin-left":"5px"}},"Copy")):Object(r["c"])("",!0)])]),t[21]||(t[21]=Object(r["e"])("div",{class:"mb-1"}," Decoded State ",-1)),Object(r["e"])("div",v,[t[16]||(t[16]=Object(r["f"])(" Is initialized: ")),Object(r["e"])("div",null,Object(r["w"])(null!==(R=e.escrowState.isInitialized)&&void 0!==R?R:"--"),1)]),Object(r["e"])("div",_,[t[17]||(t[17]=Object(r["f"])(" Initializer account: ")),Object(r["e"])("div",null,Object(r["w"])(null!==(z=e.escrowState.initializerAccountPubkey)&&void 0!==z?z:"--"),1)]),Object(r["e"])("div",P,[t[18]||(t[18]=Object(r["f"])(" X token temp account: ")),Object(r["e"])("div",null,Object(r["w"])(null!==(L=e.escrowState.XTokenTempAccountPubkey)&&void 0!==L?L:"--"),1)]),Object(r["e"])("div",E,[t[19]||(t[19]=Object(r["f"])(" Initializer Y token account: ")),Object(r["e"])("div",null,Object(r["w"])(null!==(N=e.escrowState.initializerYTokenAccount)&&void 0!==N?N:"--"),1)]),Object(r["e"])("div",T,[t[20]||(t[20]=Object(r["f"])(" ExpectedAmount: ")),Object(r["e"])("div",null,Object(r["w"])(null!==(K=e.escrowState.expectedAmount)&&void 0!==K?K:"--"),1)])])])}n("d9e2"),n("e9f5"),n("7d54");var B=n("3ecc"),x=Object(r["h"])({setup(){const e=Object(r["r"])({privateKey:"",programId:"",aliceXTokenAccountPubkey:"",aliceYTokenAccountPubkey:"",amountXTokensToSendToEscrow:0,amountYTokensAliceExpects:0}),t=Object(r["r"])({escrowAccountPubkey:null,isInitialized:null,initializerAccountPubkey:null,XTokenTempAccountPubkey:null,initializerYTokenAccount:null,expectedAmount:null}),n=Object(r["s"])(!1),i=Object(r["s"])(""),s=Object(r["s"])(""),o=Object(r["a"])(()=>""!==e.privateKey.trim()&&""!==e.programId.trim()&&""!==e.aliceXTokenAccountPubkey.trim()&&""!==e.aliceYTokenAccountPubkey.trim()&&e.amountXTokensToSendToEscrow>0&&e.amountYTokensAliceExpects>0),a=()=>{e.privateKey="",e.programId="",e.aliceXTokenAccountPubkey="",e.aliceYTokenAccountPubkey="",e.amountXTokensToSendToEscrow=0,e.amountYTokensAliceExpects=0,Object.keys(t).forEach(e=>t[e]=null),i.value="",s.value=""},c=async()=>{if(o.value){n.value=!0,i.value="",s.value="";try{const{escrowAccountPubkey:r,isInitialized:i,initializerAccountPubkey:o,XTokenTempAccountPubkey:a,initializerYTokenAccount:c,expectedAmount:u}=await Object(B["a"])(e.privateKey,e.aliceXTokenAccountPubkey,e.amountXTokensToSendToEscrow,e.aliceYTokenAccountPubkey,e.amountYTokensAliceExpects,e.programId);t.escrowAccountPubkey=r,t.isInitialized=i,t.initializerAccountPubkey=o,t.XTokenTempAccountPubkey=a,t.initializerYTokenAccount=c,t.expectedAmount=u,s.value="Escrow initialized successfully!"}catch(r){r instanceof Error?i.value=r.message:i.value=String(r)}finally{n.value=!1}}else i.value="Please fill in all fields with valid values."},u=()=>{t.escrowAccountPubkey&&(navigator.clipboard.writeText(t.escrowAccountPubkey),s.value="Escrow account pubkey copied!")};return{formState:e,resetAliceUI:a,onInitEscrow:c,escrowState:t,loading:n,errorMessage:i,successMessage:s,isFormValid:o,copyEscrowPubkey:u}}}),C=n("6b0d"),R=n.n(C);const z=R()(x,[["render",O]]);t["default"]=z},"753b":function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return s})),n.d(t,"c",(function(){return o})),n.d(t,"d",(function(){return a})),n.d(t,"i",(function(){return c})),n.d(t,"j",(function(){return u})),n.d(t,"g",(function(){return l})),n.d(t,"f",(function(){return d})),n.d(t,"e",(function(){return h})),n.d(t,"h",(function(){return b})),n.d(t,"l",(function(){return p})),n.d(t,"m",(function(){return g})),n.d(t,"k",(function(){return m}));n("d9e2");class r extends Error{constructor(e){super(e)}}class i extends r{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class s extends r{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class o extends r{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class a extends r{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}class c extends r{constructor(){super(...arguments),this.name="TokenInvalidMintError"}}class u extends r{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}class l extends r{constructor(){super(...arguments),this.name="TokenInvalidInstructionProgramError"}}class d extends r{constructor(){super(...arguments),this.name="TokenInvalidInstructionKeysError"}}class h extends r{constructor(){super(...arguments),this.name="TokenInvalidInstructionDataError"}}class b extends r{constructor(){super(...arguments),this.name="TokenInvalidInstructionTypeError"}}class p extends r{constructor(){super(...arguments),this.name="TokenTransferHookAccountNotFound"}}class g extends r{constructor(){super(...arguments),this.name="TokenTransferHookInvalidSeed"}}class m extends r{constructor(){super(...arguments),this.name="TokenTransferHookAccountDataNotFound"}}},"7b05":function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return f}));n("14d9"),n("2c66"),n("249d"),n("40e9"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1");var r=n("753b");const i=1,s=1,o=1,a=1,c=1,u=1,l=1,d=1;function h(t){if(t.length<1)throw new r["m"];const[n,...o]=t;if(o.length<n)throw new r["m"];return{data:e.from(o.slice(0,n)),packedLength:i+s+n}}function b(e,t){if(e.length<2)throw new r["m"];const[n,s]=e;if(t.length<s+n)throw new r["m"];return{data:t.subarray(n,n+s),packedLength:i+o+a}}function p(e,t){if(e.length<1)throw new r["m"];const[n]=e;if(t.length<=n)throw new r["m"];return{data:t[n].pubkey.toBuffer(),packedLength:i+c}}async function g(e,t,n){if(e.length<3)throw new r["m"];const[s,o,a]=e;if(t.length<=s)throw new r["m"];const c=await n.getAccountInfo(t[s].pubkey);if(null==c)throw new r["k"];if(c.data.length<o+a)throw new r["m"];return{data:c.data.subarray(o,o+a),packedLength:i+u+l+d}}async function m(e,t,n,i){const[s,...o]=e,a=new Uint8Array(o);switch(s){case 0:return null;case 1:return h(a);case 2:return b(a,n);case 3:return p(a,t);case 4:return g(a,t,i);default:throw new r["m"]}}async function f(e,t,n,r){const i=[];let s=0;while(s<32){const o=await m(e.slice(s),t,n,r);if(null==o)break;i.push(o.data),s+=o.packedLength}return i}}).call(this,n("1c35").Buffer)},"7f6a":function(e,t,n){"use strict";n.d(t,"a",(function(){return z})),n.d(t,"d",(function(){return q})),n.d(t,"b",(function(){return D})),n.d(t,"c",(function(){return V}));n("d9e2"),n("14d9"),n("13d5"),n("e9f5"),n("910d"),n("ab43"),n("9485");var r=n("0f06"),i=n("b9be"),s=n("f7f2"),o=n("d99e"),a=n("8df2"),c=n("633a");const u=Object(a["struct"])([Object(c["a"])("lockCpi")]),l=u.span;const d=Object(a["struct"])([Object(a["u8"])("state")]),h=d.span;const b=Object(a["struct"])([]),p=b.span;const g=Object(a["struct"])([Object(c["b"])("rateAuthority"),Object(a["ns64"])("initializationTimestamp"),Object(a["s16"])("preUpdateAverageRate"),Object(a["ns64"])("lastUpdateTimestamp"),Object(a["s16"])("currentRate")]),m=g.span;const f=Object(a["struct"])([Object(c["a"])("requireIncomingTransferMemos")]),y=f.span;n("64b9");const k=Object(a["struct"])([Object(c["b"])("authority"),Object(c["b"])("metadataAddress")]),w=k.span;const S=Object(a["struct"])([Object(c["b"])("closeAuthority")]),I=S.span;const A=Object(a["struct"])([]),v=A.span,_=A.span;const P=Object(a["struct"])([Object(c["b"])("delegate")]),E=P.span;const T=1e4;BigInt(T);function O(e){return Object(a["struct"])([Object(c["c"])("epoch"),Object(c["c"])("maximumFee"),Object(a["u16"])("transferFeeBasisPoints")],e)}const B=Object(a["struct"])([Object(c["b"])("transferFeeConfigAuthority"),Object(c["b"])("withdrawWithheldAuthority"),Object(c["c"])("withheldAmount"),O("olderTransferFee"),O("newerTransferFee")]),x=B.span;const C=Object(a["struct"])([Object(c["c"])("withheldAmount")]),R=C.span;var z,L=n("17fd");n("d6e3");(function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["TransferFeeConfig"]=1]="TransferFeeConfig",e[e["TransferFeeAmount"]=2]="TransferFeeAmount",e[e["MintCloseAuthority"]=3]="MintCloseAuthority",e[e["ConfidentialTransferMint"]=4]="ConfidentialTransferMint",e[e["ConfidentialTransferAccount"]=5]="ConfidentialTransferAccount",e[e["DefaultAccountState"]=6]="DefaultAccountState",e[e["ImmutableOwner"]=7]="ImmutableOwner",e[e["MemoTransfer"]=8]="MemoTransfer",e[e["NonTransferable"]=9]="NonTransferable",e[e["InterestBearingConfig"]=10]="InterestBearingConfig",e[e["CpiGuard"]=11]="CpiGuard",e[e["PermanentDelegate"]=12]="PermanentDelegate",e[e["NonTransferableAccount"]=13]="NonTransferableAccount",e[e["TransferHook"]=14]="TransferHook",e[e["TransferHookAccount"]=15]="TransferHookAccount",e[e["MetadataPointer"]=18]="MetadataPointer",e[e["TokenMetadata"]=19]="TokenMetadata"})(z||(z={}));const N=2,K=2;function W(e){return e+N+K}function j(e){switch(e){case z.TokenMetadata:return!0;default:return!1}}function M(e){switch(e){case z.Uninitialized:return 0;case z.TransferFeeConfig:return x;case z.TransferFeeAmount:return R;case z.MintCloseAuthority:return I;case z.ConfidentialTransferMint:return 97;case z.ConfidentialTransferAccount:return 286;case z.CpiGuard:return l;case z.DefaultAccountState:return h;case z.ImmutableOwner:return p;case z.MemoTransfer:return y;case z.MetadataPointer:return w;case z.NonTransferable:return v;case z.InterestBearingConfig:return m;case z.PermanentDelegate:return E;case z.NonTransferableAccount:return _;case z.TransferHook:return L["b"];case z.TransferHookAccount:return L["a"];case z.TokenMetadata:throw Error("Cannot get type length for variable extension type: "+e);default:throw Error("Unknown extension type: "+e)}}function U(e,t,n={}){if(0===e.length&&0===Object.keys(n).length)return t;{const t=r["a"]+o["a"]+e.filter((t,n)=>n===e.indexOf(t)).map(e=>W(M(e))).reduce((e,t)=>e+t,0)+Object.entries(n).map(([e,t])=>{if(!j(Number(e)))throw Error(`Extension ${e} is not variable length`);return W(t)}).reduce((e,t)=>e+t,0);return t===s["a"]?t+N:t}}function q(e,t={}){return U(e,i["a"],t)}function D(e){return U(e,r["a"])}function V(e,t){let n=0;while(W(n)<=t.length){const r=t.readUInt16LE(n),i=t.readUInt16LE(n+N),s=W(n);if(r==e)return t.slice(s,s+i);n=s+i}return null}},"901e6":function(e,t,n){var r;(function(i){"use strict";var s,o=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,a=Math.ceil,c=Math.floor,u="[BigNumber Error] ",l=u+"Number primitive has more than 15 significant digits: ",d=1e14,h=14,b=9007199254740991,p=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],g=1e7,m=1e9;function f(e){var t,n,r,i=K.prototype={constructor:K,toString:null,valueOf:null},s=new K(1),_=20,P=4,E=-7,T=21,O=-1e7,B=1e7,x=!1,C=1,R=0,z={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},L="0123456789abcdefghijklmnopqrstuvwxyz",N=!0;function K(e,t){var i,s,a,u,d,p,g,m,f=this;if(!(f instanceof K))return new K(e,t);if(null==t){if(e&&!0===e._isBigNumber)return f.s=e.s,void(!e.c||e.e>B?f.c=f.e=null:e.e<O?f.c=[f.e=0]:(f.e=e.e,f.c=e.c.slice()));if((p="number"==typeof e)&&0*e==0){if(f.s=1/e<0?(e=-e,-1):1,e===~~e){for(u=0,d=e;d>=10;d/=10,u++);return void(u>B?f.c=f.e=null:(f.e=u,f.c=[e]))}m=String(e)}else{if(!o.test(m=String(e)))return r(f,m,p);f.s=45==m.charCodeAt(0)?(m=m.slice(1),-1):1}(u=m.indexOf("."))>-1&&(m=m.replace(".","")),(d=m.search(/e/i))>0?(u<0&&(u=d),u+=+m.slice(d+1),m=m.substring(0,d)):u<0&&(u=m.length)}else{if(S(t,2,L.length,"Base"),10==t&&N)return f=new K(e),U(f,_+f.e+1,P);if(m=String(e),p="number"==typeof e){if(0*e!=0)return r(f,m,p,t);if(f.s=1/e<0?(m=m.slice(1),-1):1,K.DEBUG&&m.replace(/^0\.0*|\./,"").length>15)throw Error(l+e)}else f.s=45===m.charCodeAt(0)?(m=m.slice(1),-1):1;for(i=L.slice(0,t),u=d=0,g=m.length;d<g;d++)if(i.indexOf(s=m.charAt(d))<0){if("."==s){if(d>u){u=g;continue}}else if(!a&&(m==m.toUpperCase()&&(m=m.toLowerCase())||m==m.toLowerCase()&&(m=m.toUpperCase()))){a=!0,d=-1,u=0;continue}return r(f,String(e),p,t)}p=!1,m=n(m,t,10,f.s),(u=m.indexOf("."))>-1?m=m.replace(".",""):u=m.length}for(d=0;48===m.charCodeAt(d);d++);for(g=m.length;48===m.charCodeAt(--g););if(m=m.slice(d,++g)){if(g-=d,p&&K.DEBUG&&g>15&&(e>b||e!==c(e)))throw Error(l+f.s*e);if((u=u-d-1)>B)f.c=f.e=null;else if(u<O)f.c=[f.e=0];else{if(f.e=u,f.c=[],d=(u+1)%h,u<0&&(d+=h),d<g){for(d&&f.c.push(+m.slice(0,d)),g-=h;d<g;)f.c.push(+m.slice(d,d+=h));d=h-(m=m.slice(d)).length}else d-=g;for(;d--;m+="0");f.c.push(+m)}}else f.c=[f.e=0]}function W(e,t,n,r){var i,s,o,a,c;if(null==n?n=P:S(n,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=k(e.c),c=1==r||2==r&&(o<=E||o>=T)?A(c,o):v(c,o,"0");else if(e=U(new K(e),t,n),s=e.e,c=k(e.c),a=c.length,1==r||2==r&&(t<=s||s<=E)){for(;a<t;c+="0",a++);c=A(c,s)}else if(t-=o+(2===r&&s>o),c=v(c,s,"0"),s+1>a){if(--t>0)for(c+=".";t--;c+="0");}else if(t+=s-a,t>0)for(s+1==a&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function j(e,t){for(var n,r,i=1,s=new K(e[0]);i<e.length;i++)r=new K(e[i]),(!r.s||(n=w(s,r))===t||0===n&&s.s===t)&&(s=r);return s}function M(e,t,n){for(var r=1,i=t.length;!t[--i];t.pop());for(i=t[0];i>=10;i/=10,r++);return(n=r+n*h-1)>B?e.c=e.e=null:n<O?e.c=[e.e=0]:(e.e=n,e.c=t),e}function U(e,t,n,r){var i,s,o,u,l,b,g,m=e.c,f=p;if(m){e:{for(i=1,u=m[0];u>=10;u/=10,i++);if(s=t-i,s<0)s+=h,o=t,l=m[b=0],g=c(l/f[i-o-1]%10);else if(b=a((s+1)/h),b>=m.length){if(!r)break e;for(;m.length<=b;m.push(0));l=g=0,i=1,s%=h,o=s-h+1}else{for(l=u=m[b],i=1;u>=10;u/=10,i++);s%=h,o=s-h+i,g=o<0?0:c(l/f[i-o-1]%10)}if(r=r||t<0||null!=m[b+1]||(o<0?l:l%f[i-o-1]),r=n<4?(g||r)&&(0==n||n==(e.s<0?3:2)):g>5||5==g&&(4==n||r||6==n&&(s>0?o>0?l/f[i-o]:0:m[b-1])%10&1||n==(e.s<0?8:7)),t<1||!m[0])return m.length=0,r?(t-=e.e+1,m[0]=f[(h-t%h)%h],e.e=-t||0):m[0]=e.e=0,e;if(0==s?(m.length=b,u=1,b--):(m.length=b+1,u=f[h-s],m[b]=o>0?c(l/f[i-o]%f[o])*u:0),r)for(;;){if(0==b){for(s=1,o=m[0];o>=10;o/=10,s++);for(o=m[0]+=u,u=1;o>=10;o/=10,u++);s!=u&&(e.e++,m[0]==d&&(m[0]=1));break}if(m[b]+=u,m[b]!=d)break;m[b--]=0,u=1}for(s=m.length;0===m[--s];m.pop());}e.e>B?e.c=e.e=null:e.e<O&&(e.c=[e.e=0])}return e}function q(e){var t,n=e.e;return null===n?e.toString():(t=k(e.c),t=n<=E||n>=T?A(t,n):v(t,n,"0"),e.s<0?"-"+t:t)}return K.clone=f,K.ROUND_UP=0,K.ROUND_DOWN=1,K.ROUND_CEIL=2,K.ROUND_FLOOR=3,K.ROUND_HALF_UP=4,K.ROUND_HALF_DOWN=5,K.ROUND_HALF_EVEN=6,K.ROUND_HALF_CEIL=7,K.ROUND_HALF_FLOOR=8,K.EUCLID=9,K.config=K.set=function(e){var t,n;if(null!=e){if("object"!=typeof e)throw Error(u+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(n=e[t],S(n,0,m,t),_=n),e.hasOwnProperty(t="ROUNDING_MODE")&&(n=e[t],S(n,0,8,t),P=n),e.hasOwnProperty(t="EXPONENTIAL_AT")&&(n=e[t],n&&n.pop?(S(n[0],-m,0,t),S(n[1],0,m,t),E=n[0],T=n[1]):(S(n,-m,m,t),E=-(T=n<0?-n:n))),e.hasOwnProperty(t="RANGE"))if(n=e[t],n&&n.pop)S(n[0],-m,-1,t),S(n[1],1,m,t),O=n[0],B=n[1];else{if(S(n,-m,m,t),!n)throw Error(u+t+" cannot be zero: "+n);O=-(B=n<0?-n:n)}if(e.hasOwnProperty(t="CRYPTO")){if(n=e[t],n!==!!n)throw Error(u+t+" not true or false: "+n);if(n){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw x=!n,Error(u+"crypto unavailable");x=n}else x=n}if(e.hasOwnProperty(t="MODULO_MODE")&&(n=e[t],S(n,0,9,t),C=n),e.hasOwnProperty(t="POW_PRECISION")&&(n=e[t],S(n,0,m,t),R=n),e.hasOwnProperty(t="FORMAT")){if(n=e[t],"object"!=typeof n)throw Error(u+t+" not an object: "+n);z=n}if(e.hasOwnProperty(t="ALPHABET")){if(n=e[t],"string"!=typeof n||/^.?$|[+\-.\s]|(.).*\1/.test(n))throw Error(u+t+" invalid: "+n);N="0123456789"==n.slice(0,10),L=n}}return{DECIMAL_PLACES:_,ROUNDING_MODE:P,EXPONENTIAL_AT:[E,T],RANGE:[O,B],CRYPTO:x,MODULO_MODE:C,POW_PRECISION:R,FORMAT:z,ALPHABET:L}},K.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!K.DEBUG)return!0;var t,n,r=e.c,i=e.e,s=e.s;e:if("[object Array]"=={}.toString.call(r)){if((1===s||-1===s)&&i>=-m&&i<=m&&i===c(i)){if(0===r[0]){if(0===i&&1===r.length)return!0;break e}if(t=(i+1)%h,t<1&&(t+=h),String(r[0]).length==t){for(t=0;t<r.length;t++)if(n=r[t],n<0||n>=d||n!==c(n))break e;if(0!==n)return!0}}}else if(null===r&&null===i&&(null===s||1===s||-1===s))return!0;throw Error(u+"Invalid BigNumber: "+e)},K.maximum=K.max=function(){return j(arguments,-1)},K.minimum=K.min=function(){return j(arguments,1)},K.random=function(){var e=9007199254740992,t=Math.random()*e&2097151?function(){return c(Math.random()*e)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)};return function(e){var n,r,i,o,l,d=0,b=[],g=new K(s);if(null==e?e=_:S(e,0,m),o=a(e/h),x)if(crypto.getRandomValues){for(n=crypto.getRandomValues(new Uint32Array(o*=2));d<o;)l=131072*n[d]+(n[d+1]>>>11),l>=9e15?(r=crypto.getRandomValues(new Uint32Array(2)),n[d]=r[0],n[d+1]=r[1]):(b.push(l%1e14),d+=2);d=o/2}else{if(!crypto.randomBytes)throw x=!1,Error(u+"crypto unavailable");for(n=crypto.randomBytes(o*=7);d<o;)l=281474976710656*(31&n[d])+1099511627776*n[d+1]+4294967296*n[d+2]+16777216*n[d+3]+(n[d+4]<<16)+(n[d+5]<<8)+n[d+6],l>=9e15?crypto.randomBytes(7).copy(n,d):(b.push(l%1e14),d+=7);d=o/7}if(!x)for(;d<o;)l=t(),l<9e15&&(b[d++]=l%1e14);for(o=b[--d],e%=h,o&&e&&(l=p[h-e],b[d]=c(o/l)*l);0===b[d];b.pop(),d--);if(d<0)b=[i=0];else{for(i=-1;0===b[0];b.splice(0,1),i-=h);for(d=1,l=b[0];l>=10;l/=10,d++);d<h&&(i-=h-d)}return g.e=i,g.c=b,g}}(),K.sum=function(){for(var e=1,t=arguments,n=new K(t[0]);e<t.length;)n=n.plus(t[e++]);return n},n=function(){var e="0123456789";function n(e,t,n,r){for(var i,s,o=[0],a=0,c=e.length;a<c;){for(s=o.length;s--;o[s]*=t);for(o[0]+=r.indexOf(e.charAt(a++)),i=0;i<o.length;i++)o[i]>n-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/n|0,o[i]%=n)}return o.reverse()}return function(r,i,s,o,a){var c,u,l,d,h,b,p,g,m=r.indexOf("."),f=_,y=P;for(m>=0&&(d=R,R=0,r=r.replace(".",""),g=new K(i),b=g.pow(r.length-m),R=d,g.c=n(v(k(b.c),b.e,"0"),10,s,e),g.e=g.c.length),p=n(r,i,s,a?(c=L,e):(c=e,L)),l=d=p.length;0==p[--d];p.pop());if(!p[0])return c.charAt(0);if(m<0?--l:(b.c=p,b.e=l,b.s=o,b=t(b,g,f,y,s),p=b.c,h=b.r,l=b.e),u=l+f+1,m=p[u],d=s/2,h=h||u<0||null!=p[u+1],h=y<4?(null!=m||h)&&(0==y||y==(b.s<0?3:2)):m>d||m==d&&(4==y||h||6==y&&1&p[u-1]||y==(b.s<0?8:7)),u<1||!p[0])r=h?v(c.charAt(1),-f,c.charAt(0)):c.charAt(0);else{if(p.length=u,h)for(--s;++p[--u]>s;)p[u]=0,u||(++l,p=[1].concat(p));for(d=p.length;!p[--d];);for(m=0,r="";m<=d;r+=c.charAt(p[m++]));r=v(r,l,c.charAt(0))}return r}}(),t=function(){function e(e,t,n){var r,i,s,o,a=0,c=e.length,u=t%g,l=t/g|0;for(e=e.slice();c--;)s=e[c]%g,o=e[c]/g|0,r=l*s+o*u,i=u*s+r%g*g+a,a=(i/n|0)+(r/g|0)+l*o,e[c]=i%n;return a&&(e=[a].concat(e)),e}function t(e,t,n,r){var i,s;if(n!=r)s=n>r?1:-1;else for(i=s=0;i<n;i++)if(e[i]!=t[i]){s=e[i]>t[i]?1:-1;break}return s}function n(e,t,n,r){for(var i=0;n--;)e[n]-=i,i=e[n]<t[n]?1:0,e[n]=i*r+e[n]-t[n];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(r,i,s,o,a){var u,l,b,p,g,m,f,k,w,S,I,A,v,_,P,E,T,O=r.s==i.s?1:-1,B=r.c,x=i.c;if(!B||!B[0]||!x||!x[0])return new K(r.s&&i.s&&(B?!x||B[0]!=x[0]:x)?B&&0==B[0]||!x?0*O:O/0:NaN);for(k=new K(O),w=k.c=[],l=r.e-i.e,O=s+l+1,a||(a=d,l=y(r.e/h)-y(i.e/h),O=O/h|0),b=0;x[b]==(B[b]||0);b++);if(x[b]>(B[b]||0)&&l--,O<0)w.push(1),p=!0;else{for(_=B.length,E=x.length,b=0,O+=2,g=c(a/(x[0]+1)),g>1&&(x=e(x,g,a),B=e(B,g,a),E=x.length,_=B.length),v=E,S=B.slice(0,E),I=S.length;I<E;S[I++]=0);T=x.slice(),T=[0].concat(T),P=x[0],x[1]>=a/2&&P++;do{if(g=0,u=t(x,S,E,I),u<0){if(A=S[0],E!=I&&(A=A*a+(S[1]||0)),g=c(A/P),g>1){g>=a&&(g=a-1),m=e(x,g,a),f=m.length,I=S.length;while(1==t(m,S,f,I))g--,n(m,E<f?T:x,f,a),f=m.length,u=1}else 0==g&&(u=g=1),m=x.slice(),f=m.length;if(f<I&&(m=[0].concat(m)),n(S,m,I,a),I=S.length,-1==u)while(t(x,S,E,I)<1)g++,n(S,E<I?T:x,I,a),I=S.length}else 0===u&&(g++,S=[0]);w[b++]=g,S[0]?S[I++]=B[v]||0:(S=[B[v]],I=1)}while((v++<_||null!=S[0])&&O--);p=null!=S[0],w[0]||w.splice(0,1)}if(a==d){for(b=1,O=w[0];O>=10;O/=10,b++);U(k,s+(k.e=b+l*h-1)+1,o,p)}else k.e=l,k.r=+p;return k}}(),r=function(){var e=/^(-?)0([xbo])(?=\w[\w.]*$)/i,t=/^([^.]+)\.$/,n=/^\.([^.]+)$/,r=/^-?(Infinity|NaN)$/,i=/^\s*\+(?=[\w.])|^\s+|\s+$/g;return function(s,o,a,c){var l,d=a?o:o.replace(i,"");if(r.test(d))s.s=isNaN(d)?null:d<0?-1:1;else{if(!a&&(d=d.replace(e,(function(e,t,n){return l="x"==(n=n.toLowerCase())?16:"b"==n?2:8,c&&c!=l?e:t})),c&&(l=c,d=d.replace(t,"$1").replace(n,"0.$1")),o!=d))return new K(d,l);if(K.DEBUG)throw Error(u+"Not a"+(c?" base "+c:"")+" number: "+o);s.s=null}s.c=s.e=null}}(),i.absoluteValue=i.abs=function(){var e=new K(this);return e.s<0&&(e.s=1),e},i.comparedTo=function(e,t){return w(this,new K(e,t))},i.decimalPlaces=i.dp=function(e,t){var n,r,i,s=this;if(null!=e)return S(e,0,m),null==t?t=P:S(t,0,8),U(new K(s),e+s.e+1,t);if(!(n=s.c))return null;if(r=((i=n.length-1)-y(this.e/h))*h,i=n[i])for(;i%10==0;i/=10,r--);return r<0&&(r=0),r},i.dividedBy=i.div=function(e,n){return t(this,new K(e,n),_,P)},i.dividedToIntegerBy=i.idiv=function(e,n){return t(this,new K(e,n),0,1)},i.exponentiatedBy=i.pow=function(e,t){var n,r,i,o,l,d,b,p,g,m=this;if(e=new K(e),e.c&&!e.isInteger())throw Error(u+"Exponent not an integer: "+q(e));if(null!=t&&(t=new K(t)),d=e.e>14,!m.c||!m.c[0]||1==m.c[0]&&!m.e&&1==m.c.length||!e.c||!e.c[0])return g=new K(Math.pow(+q(m),d?e.s*(2-I(e)):+q(e))),t?g.mod(t):g;if(b=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new K(NaN);r=!b&&m.isInteger()&&t.isInteger(),r&&(m=m.mod(t))}else{if(e.e>9&&(m.e>0||m.e<-1||(0==m.e?m.c[0]>1||d&&m.c[1]>=24e7:m.c[0]<8e13||d&&m.c[0]<=9999975e7)))return o=m.s<0&&I(e)?-0:0,m.e>-1&&(o=1/o),new K(b?1/o:o);R&&(o=a(R/h+2))}for(d?(n=new K(.5),b&&(e.s=1),p=I(e)):(i=Math.abs(+q(e)),p=i%2),g=new K(s);;){if(p){if(g=g.times(m),!g.c)break;o?g.c.length>o&&(g.c.length=o):r&&(g=g.mod(t))}if(i){if(i=c(i/2),0===i)break;p=i%2}else if(e=e.times(n),U(e,e.e+1,1),e.e>14)p=I(e);else{if(i=+q(e),0===i)break;p=i%2}m=m.times(m),o?m.c&&m.c.length>o&&(m.c.length=o):r&&(m=m.mod(t))}return r?g:(b&&(g=s.div(g)),t?g.mod(t):o?U(g,R,P,l):g)},i.integerValue=function(e){var t=new K(this);return null==e?e=P:S(e,0,8),U(t,t.e+1,e)},i.isEqualTo=i.eq=function(e,t){return 0===w(this,new K(e,t))},i.isFinite=function(){return!!this.c},i.isGreaterThan=i.gt=function(e,t){return w(this,new K(e,t))>0},i.isGreaterThanOrEqualTo=i.gte=function(e,t){return 1===(t=w(this,new K(e,t)))||0===t},i.isInteger=function(){return!!this.c&&y(this.e/h)>this.c.length-2},i.isLessThan=i.lt=function(e,t){return w(this,new K(e,t))<0},i.isLessThanOrEqualTo=i.lte=function(e,t){return-1===(t=w(this,new K(e,t)))||0===t},i.isNaN=function(){return!this.s},i.isNegative=function(){return this.s<0},i.isPositive=function(){return this.s>0},i.isZero=function(){return!!this.c&&0==this.c[0]},i.minus=function(e,t){var n,r,i,s,o=this,a=o.s;if(e=new K(e,t),t=e.s,!a||!t)return new K(NaN);if(a!=t)return e.s=-t,o.plus(e);var c=o.e/h,u=e.e/h,l=o.c,b=e.c;if(!c||!u){if(!l||!b)return l?(e.s=-t,e):new K(b?o:NaN);if(!l[0]||!b[0])return b[0]?(e.s=-t,e):new K(l[0]?o:3==P?-0:0)}if(c=y(c),u=y(u),l=l.slice(),a=c-u){for((s=a<0)?(a=-a,i=l):(u=c,i=b),i.reverse(),t=a;t--;i.push(0));i.reverse()}else for(r=(s=(a=l.length)<(t=b.length))?a:t,a=t=0;t<r;t++)if(l[t]!=b[t]){s=l[t]<b[t];break}if(s&&(i=l,l=b,b=i,e.s=-e.s),t=(r=b.length)-(n=l.length),t>0)for(;t--;l[n++]=0);for(t=d-1;r>a;){if(l[--r]<b[r]){for(n=r;n&&!l[--n];l[n]=t);--l[n],l[r]+=d}l[r]-=b[r]}for(;0==l[0];l.splice(0,1),--u);return l[0]?M(e,l,u):(e.s=3==P?-1:1,e.c=[e.e=0],e)},i.modulo=i.mod=function(e,n){var r,i,s=this;return e=new K(e,n),!s.c||!e.s||e.c&&!e.c[0]?new K(NaN):!e.c||s.c&&!s.c[0]?new K(s):(9==C?(i=e.s,e.s=1,r=t(s,e,0,3),e.s=i,r.s*=i):r=t(s,e,0,C),e=s.minus(r.times(e)),e.c[0]||1!=C||(e.s=s.s),e)},i.multipliedBy=i.times=function(e,t){var n,r,i,s,o,a,c,u,l,b,p,m,f,k,w,S=this,I=S.c,A=(e=new K(e,t)).c;if(!I||!A||!I[0]||!A[0])return!S.s||!e.s||I&&!I[0]&&!A||A&&!A[0]&&!I?e.c=e.e=e.s=null:(e.s*=S.s,I&&A?(e.c=[0],e.e=0):e.c=e.e=null),e;for(r=y(S.e/h)+y(e.e/h),e.s*=S.s,c=I.length,b=A.length,c<b&&(f=I,I=A,A=f,i=c,c=b,b=i),i=c+b,f=[];i--;f.push(0));for(k=d,w=g,i=b;--i>=0;){for(n=0,p=A[i]%w,m=A[i]/w|0,o=c,s=i+o;s>i;)u=I[--o]%w,l=I[o]/w|0,a=m*u+l*p,u=p*u+a%w*w+f[s]+n,n=(u/k|0)+(a/w|0)+m*l,f[s--]=u%k;f[s]=n}return n?++r:f.splice(0,1),M(e,f,r)},i.negated=function(){var e=new K(this);return e.s=-e.s||null,e},i.plus=function(e,t){var n,r=this,i=r.s;if(e=new K(e,t),t=e.s,!i||!t)return new K(NaN);if(i!=t)return e.s=-t,r.minus(e);var s=r.e/h,o=e.e/h,a=r.c,c=e.c;if(!s||!o){if(!a||!c)return new K(i/0);if(!a[0]||!c[0])return c[0]?e:new K(a[0]?r:0*i)}if(s=y(s),o=y(o),a=a.slice(),i=s-o){for(i>0?(o=s,n=c):(i=-i,n=a),n.reverse();i--;n.push(0));n.reverse()}for(i=a.length,t=c.length,i-t<0&&(n=c,c=a,a=n,t=i),i=0;t;)i=(a[--t]=a[t]+c[t]+i)/d|0,a[t]=d===a[t]?0:a[t]%d;return i&&(a=[i].concat(a),++o),M(e,a,o)},i.precision=i.sd=function(e,t){var n,r,i,s=this;if(null!=e&&e!==!!e)return S(e,1,m),null==t?t=P:S(t,0,8),U(new K(s),e,t);if(!(n=s.c))return null;if(i=n.length-1,r=i*h+1,i=n[i]){for(;i%10==0;i/=10,r--);for(i=n[0];i>=10;i/=10,r++);}return e&&s.e+1>r&&(r=s.e+1),r},i.shiftedBy=function(e){return S(e,-b,b),this.times("1e"+e)},i.squareRoot=i.sqrt=function(){var e,n,r,i,s,o=this,a=o.c,c=o.s,u=o.e,l=_+4,d=new K("0.5");if(1!==c||!a||!a[0])return new K(!c||c<0&&(!a||a[0])?NaN:a?o:1/0);if(c=Math.sqrt(+q(o)),0==c||c==1/0?(n=k(a),(n.length+u)%2==0&&(n+="0"),c=Math.sqrt(+n),u=y((u+1)/2)-(u<0||u%2),c==1/0?n="5e"+u:(n=c.toExponential(),n=n.slice(0,n.indexOf("e")+1)+u),r=new K(n)):r=new K(c+""),r.c[0])for(u=r.e,c=u+l,c<3&&(c=0);;)if(s=r,r=d.times(s.plus(t(o,s,l,1))),k(s.c).slice(0,c)===(n=k(r.c)).slice(0,c)){if(r.e<u&&--c,n=n.slice(c-3,c+1),"9999"!=n&&(i||"4999"!=n)){+n&&(+n.slice(1)||"5"!=n.charAt(0))||(U(r,r.e+_+2,1),e=!r.times(r).eq(o));break}if(!i&&(U(s,s.e+_+2,0),s.times(s).eq(o))){r=s;break}l+=4,c+=4,i=1}return U(r,r.e+_+1,P,e)},i.toExponential=function(e,t){return null!=e&&(S(e,0,m),e++),W(this,e,t,1)},i.toFixed=function(e,t){return null!=e&&(S(e,0,m),e=e+this.e+1),W(this,e,t)},i.toFormat=function(e,t,n){var r,i=this;if(null==n)null!=e&&t&&"object"==typeof t?(n=t,t=null):e&&"object"==typeof e?(n=e,e=t=null):n=z;else if("object"!=typeof n)throw Error(u+"Argument not an object: "+n);if(r=i.toFixed(e,t),i.c){var s,o=r.split("."),a=+n.groupSize,c=+n.secondaryGroupSize,l=n.groupSeparator||"",d=o[0],h=o[1],b=i.s<0,p=b?d.slice(1):d,g=p.length;if(c&&(s=a,a=c,c=s,g-=s),a>0&&g>0){for(s=g%a||a,d=p.substr(0,s);s<g;s+=a)d+=l+p.substr(s,a);c>0&&(d+=l+p.slice(s)),b&&(d="-"+d)}r=h?d+(n.decimalSeparator||"")+((c=+n.fractionGroupSize)?h.replace(new RegExp("\\d{"+c+"}\\B","g"),"$&"+(n.fractionGroupSeparator||"")):h):d}return(n.prefix||"")+r+(n.suffix||"")},i.toFraction=function(e){var n,r,i,o,a,c,l,d,b,g,m,f,y=this,w=y.c;if(null!=e&&(l=new K(e),!l.isInteger()&&(l.c||1!==l.s)||l.lt(s)))throw Error(u+"Argument "+(l.isInteger()?"out of range: ":"not an integer: ")+q(l));if(!w)return new K(y);for(n=new K(s),b=r=new K(s),i=d=new K(s),f=k(w),a=n.e=f.length-y.e-1,n.c[0]=p[(c=a%h)<0?h+c:c],e=!e||l.comparedTo(n)>0?a>0?n:b:l,c=B,B=1/0,l=new K(f),d.c[0]=0;;){if(g=t(l,n,0,1),o=r.plus(g.times(i)),1==o.comparedTo(e))break;r=i,i=o,b=d.plus(g.times(o=b)),d=o,n=l.minus(g.times(o=n)),l=o}return o=t(e.minus(r),i,0,1),d=d.plus(o.times(b)),r=r.plus(o.times(i)),d.s=b.s=y.s,a*=2,m=t(b,i,a,P).minus(y).abs().comparedTo(t(d,r,a,P).minus(y).abs())<1?[b,i]:[d,r],B=c,m},i.toNumber=function(){return+q(this)},i.toPrecision=function(e,t){return null!=e&&S(e,1,m),W(this,e,t,2)},i.toString=function(e){var t,r=this,i=r.s,s=r.e;return null===s?i?(t="Infinity",i<0&&(t="-"+t)):t="NaN":(null==e?t=s<=E||s>=T?A(k(r.c),s):v(k(r.c),s,"0"):10===e&&N?(r=U(new K(r),_+s+1,P),t=v(k(r.c),r.e,"0")):(S(e,2,L.length,"Base"),t=n(v(k(r.c),s,"0"),10,e,i,!0)),i<0&&r.c[0]&&(t="-"+t)),t},i.valueOf=i.toJSON=function(){return q(this)},i._isBigNumber=!0,null!=e&&K.set(e),K}function y(e){var t=0|e;return e>0||e===t?t:t-1}function k(e){for(var t,n,r=1,i=e.length,s=e[0]+"";r<i;){for(t=e[r++]+"",n=h-t.length;n--;t="0"+t);s+=t}for(i=s.length;48===s.charCodeAt(--i););return s.slice(0,i+1||1)}function w(e,t){var n,r,i=e.c,s=t.c,o=e.s,a=t.s,c=e.e,u=t.e;if(!o||!a)return null;if(n=i&&!i[0],r=s&&!s[0],n||r)return n?r?0:-a:o;if(o!=a)return o;if(n=o<0,r=c==u,!i||!s)return r?0:!i^n?1:-1;if(!r)return c>u^n?1:-1;for(a=(c=i.length)<(u=s.length)?c:u,o=0;o<a;o++)if(i[o]!=s[o])return i[o]>s[o]^n?1:-1;return c==u?0:c>u^n?1:-1}function S(e,t,n,r){if(e<t||e>n||e!==c(e))throw Error(u+(r||"Argument")+("number"==typeof e?e<t||e>n?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function I(e){var t=e.c.length-1;return y(e.e/h)==t&&e.c[t]%2!=0}function A(e,t){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function v(e,t,n){var r,i;if(t<0){for(i=n+".";++t;i+=n);e=i+e}else if(r=e.length,++t>r){for(i=n,t-=r;--t;i+=n);e+=i}else t<r&&(e=e.slice(0,t)+"."+e.slice(t));return e}s=f(),s["default"]=s.BigNumber=s,r=function(){return s}.call(t,n,t,e),void 0===r||(e.exports=r)})()},"9ea2":function(e,t,n){"use strict";(function(e){function n(t){{const n=e.from(t);n.reverse();const r=n.toString("hex");return 0===r.length?BigInt(0):BigInt("0x"+r)}}function r(e){{const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt("0x"+t)}}function i(t,n){{const r=t.toString(16),i=e.from(r.padStart(2*n,"0").slice(0,2*n),"hex");return i.reverse(),i}}function s(t,n){{const r=t.toString(16);return e.from(r.padStart(2*n,"0").slice(0,2*n),"hex")}}Object.defineProperty(t,"__esModule",{value:!0}),t.toBigIntLE=n,t.toBigIntBE=r,t.toBufferLE=i,t.toBufferBE=s}).call(this,n("1c35").Buffer)},a81a:function(e,t,n){"use strict";(function(e){n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return u}));var r=n("8df2"),i=n("9ea2"),s=n("bbae");const o=t=>n=>{const o=Object(r["blob"])(t,n),{encode:a,decode:c}=Object(s["a"])(o),u=o;return u.decode=(t,n)=>{const r=c(t,n);return Object(i["toBigIntLE"])(e.from(r))},u.encode=(e,n,r)=>{const s=Object(i["toBufferLE"])(e,t);return a(s,n,r)},u},a=t=>n=>{const o=Object(r["blob"])(t,n),{encode:a,decode:c}=Object(s["a"])(o),u=o;return u.decode=(t,n)=>{const r=c(t,n);return Object(i["toBigIntBE"])(e.from(r))},u.encode=(e,n,r)=>{const s=Object(i["toBufferBE"])(e,t);return a(s,n,r)},u},c=o(8),u=(a(8),o(16));a(16),o(24),a(24),o(32),a(32)}).call(this,n("1c35").Buffer)},abed:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));n("14d9");var r=n("64b9");function i(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const t of n)e.push({pubkey:t instanceof r["c"]?t:t.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}},b9be:function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n("8df2"),i=n("633a"),s=(n("64b9"),n("d6e3")),o=n("753b"),a=n("d99e"),c=(n("7f6a"),n("0f06")),u=n("f7f2");const l=Object(r["struct"])([Object(r["u32"])("mintAuthorityOption"),Object(i["b"])("mintAuthority"),Object(i["c"])("supply"),Object(r["u8"])("decimals"),Object(i["a"])("isInitialized"),Object(r["u32"])("freezeAuthorityOption"),Object(i["b"])("freezeAuthority")]),d=l.span;function h(t,n,r=s["c"]){if(!n)throw new o["a"];if(!n.owner.equals(r))throw new o["c"];if(n.data.length<d)throw new o["d"];const i=l.decode(n.data.slice(0,d));let h=e.alloc(0);if(n.data.length>d){if(n.data.length<=c["a"])throw new o["d"];if(n.data.length===u["a"])throw new o["d"];if(n.data[c["a"]]!=a["b"].Mint)throw new o["i"];h=n.data.slice(c["a"]+a["a"])}return{address:t,mintAuthority:i.mintAuthorityOption?i.mintAuthority:null,supply:i.supply,decimals:i.decimals,isInitialized:i.isInitialized,freezeAuthority:i.freezeAuthorityOption?i.freezeAuthority:null,tlvData:h}}}).call(this,n("1c35").Buffer)},bbae:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));const r=e=>{const t=e.decode.bind(e),n=e.encode.bind(e);return{decode:t,encode:n}}},d99e:function(e,t,n){"use strict";var r;n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return i})),function(e){e[e["Uninitialized"]=0]="Uninitialized",e[e["Mint"]=1]="Mint",e[e["Account"]=2]="Account"}(r||(r={}));const i=1},f7f2:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("8df2"),i=n("633a");n("d6e3"),n("753b");const s=Object(r["struct"])([Object(r["u8"])("m"),Object(r["u8"])("n"),Object(i["a"])("isInitialized"),Object(i["b"])("signer1"),Object(i["b"])("signer2"),Object(i["b"])("signer3"),Object(i["b"])("signer4"),Object(i["b"])("signer5"),Object(i["b"])("signer6"),Object(i["b"])("signer7"),Object(i["b"])("signer8"),Object(i["b"])("signer9"),Object(i["b"])("signer10"),Object(i["b"])("signer11")]),o=s.span},fbe3:function(e,t,n){"use strict";var r;n.d(t,"a",(function(){return r})),function(e){e[e["InitializeMint"]=0]="InitializeMint",e[e["InitializeAccount"]=1]="InitializeAccount",e[e["InitializeMultisig"]=2]="InitializeMultisig",e[e["Transfer"]=3]="Transfer",e[e["Approve"]=4]="Approve",e[e["Revoke"]=5]="Revoke",e[e["SetAuthority"]=6]="SetAuthority",e[e["MintTo"]=7]="MintTo",e[e["Burn"]=8]="Burn",e[e["CloseAccount"]=9]="CloseAccount",e[e["FreezeAccount"]=10]="FreezeAccount",e[e["ThawAccount"]=11]="ThawAccount",e[e["TransferChecked"]=12]="TransferChecked",e[e["ApproveChecked"]=13]="ApproveChecked",e[e["MintToChecked"]=14]="MintToChecked",e[e["BurnChecked"]=15]="BurnChecked",e[e["InitializeAccount2"]=16]="InitializeAccount2",e[e["SyncNative"]=17]="SyncNative",e[e["InitializeAccount3"]=18]="InitializeAccount3",e[e["InitializeMultisig2"]=19]="InitializeMultisig2",e[e["InitializeMint2"]=20]="InitializeMint2",e[e["GetAccountDataSize"]=21]="GetAccountDataSize",e[e["InitializeImmutableOwner"]=22]="InitializeImmutableOwner",e[e["AmountToUiAmount"]=23]="AmountToUiAmount",e[e["UiAmountToAmount"]=24]="UiAmountToAmount",e[e["InitializeMintCloseAuthority"]=25]="InitializeMintCloseAuthority",e[e["TransferFeeExtension"]=26]="TransferFeeExtension",e[e["ConfidentialTransferExtension"]=27]="ConfidentialTransferExtension",e[e["DefaultAccountStateExtension"]=28]="DefaultAccountStateExtension",e[e["Reallocate"]=29]="Reallocate",e[e["MemoTransferExtension"]=30]="MemoTransferExtension",e[e["CreateNativeMint"]=31]="CreateNativeMint",e[e["InitializeNonTransferableMint"]=32]="InitializeNonTransferableMint",e[e["InterestBearingMintExtension"]=33]="InterestBearingMintExtension",e[e["CpiGuardExtension"]=34]="CpiGuardExtension",e[e["InitializePermanentDelegate"]=35]="InitializePermanentDelegate",e[e["TransferHookExtension"]=36]="TransferHookExtension",e[e["MetadataPointerExtension"]=39]="MetadataPointerExtension"}(r||(r={}))}}]);
//# sourceMappingURL=chunk-62353fb4.e92101c9.js.map